{
    "sourceFile": "node_modules/mongoose/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1642658350533,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1642658350533,
            "name": "Commit-0",
            "content": "declare module 'mongoose' {\n  import events = require('events');\n  import mongodb = require('mongodb');\n  import mongoose = require('mongoose');\n  import stream = require('stream');\n\n  export enum ConnectionStates {\n    disconnected = 0,\n    connected = 1,\n    connecting = 2,\n    disconnecting = 3,\n    uninitialized = 99,\n  }\n\n  class NativeDate extends global.Date {}\n\n  /** The Mongoose Date [SchemaType](/docs/schematypes.html). */\n  export type Date = Schema.Types.Date;\n\n  /**\n   * The Mongoose Decimal128 [SchemaType](/docs/schematypes.html). Used for\n   * declaring paths in your schema that should be\n   * [128-bit decimal floating points](http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-decimal.html).\n   * Do not use this to create a new Decimal128 instance, use `mongoose.Types.Decimal128`\n   * instead.\n   */\n  export type Decimal128 = Schema.Types.Decimal128;\n\n  /**\n   * The Mongoose Mixed [SchemaType](/docs/schematypes.html). Used for\n   * declaring paths in your schema that Mongoose's change tracking, casting,\n   * and validation should ignore.\n   */\n  export type Mixed = Schema.Types.Mixed;\n\n  /**\n   * Mongoose constructor. The exports object of the `mongoose` module is an instance of this\n   * class. Most apps will only use this one instance.\n   */\n  export const Mongoose: new (options?: MongooseOptions | null) => typeof mongoose;\n\n  /**\n   * The Mongoose Number [SchemaType](/docs/schematypes.html). Used for\n   * declaring paths in your schema that Mongoose should cast to numbers.\n   */\n  export type Number = Schema.Types.Number;\n\n  /**\n   * The Mongoose ObjectId [SchemaType](/docs/schematypes.html). Used for\n   * declaring paths in your schema that should be\n   * [MongoDB ObjectIds](https://docs.mongodb.com/manual/reference/method/ObjectId/).\n   * Do not use this to create a new ObjectId instance, use `mongoose.Types.ObjectId`\n   * instead.\n   */\n  export type ObjectId = Schema.Types.ObjectId;\n\n  export let Promise: any;\n  export const PromiseProvider: any;\n\n  /** The various Mongoose SchemaTypes. */\n  export const SchemaTypes: typeof Schema.Types;\n\n  /** Expose connection states for user-land */\n  export const STATES: typeof ConnectionStates;\n\n  /** Opens Mongoose's default connection to MongoDB, see [connections docs](https://mongoosejs.com/docs/connections.html) */\n  export function connect(uri: string, options: ConnectOptions, callback: CallbackWithoutResult): void;\n  export function connect(uri: string, callback: CallbackWithoutResult): void;\n  export function connect(uri: string, options?: ConnectOptions): Promise<Mongoose>;\n\n  /**\n     * Makes the indexes in MongoDB match the indexes defined in every model's\n     * schema. This function will drop any indexes that are not defined in\n     * the model's schema except the `_id` index, and build any indexes that\n     * are in your schema but not in MongoDB.\n     */\n  export function syncIndexes(options?: Record<string, unknown>): Promise<Array<string>>;\n  export function syncIndexes(options: Record<string, unknown> | null, callback: Callback<Array<string>>): void;\n\n  /* Tells `sanitizeFilter()` to skip the given object when filtering out potential query selector injection attacks.\n   * Use this method when you have a known query selector that you want to use. */\n  export function trusted<T>(obj: T): T;\n\n  /** The Mongoose module's default connection. Equivalent to `mongoose.connections[0]`, see [`connections`](#mongoose_Mongoose-connections). */\n  export const connection: Connection;\n\n  /** An array containing all connections associated with this Mongoose instance. */\n  export const connections: Connection[];\n\n  /**\n   * Can be extended to explicitly type specific models.\n   */\n  interface Models {\n    [modelName: string]: Model<any>\n  }\n\n  /** An array containing all models associated with this Mongoose instance. */\n  export const models: Models;\n  /** Creates a Connection instance. */\n  export function createConnection(uri: string, options?: ConnectOptions): Connection;\n  export function createConnection(): Connection;\n  export function createConnection(uri: string, options: ConnectOptions, callback: Callback<Connection>): void;\n\n  /**\n   * Removes the model named `name` from the default connection, if it exists.\n   * You can use this function to clean up any models you created in your tests to\n   * prevent OverwriteModelErrors.\n   */\n  export function deleteModel(name: string | RegExp): typeof mongoose;\n\n  export function disconnect(): Promise<void>;\n  export function disconnect(cb: CallbackWithoutResult): void;\n\n  /** Gets mongoose options */\n  export function get<K extends keyof MongooseOptions>(key: K): MongooseOptions[K];\n\n  /*! ignore */\n  type CompileModelOptions = { overwriteModels?: boolean, connection?: Connection };\n\n  /**\n   * Returns true if Mongoose can cast the given value to an ObjectId, or\n   * false otherwise.\n   */\n  export function isValidObjectId(v: any): boolean;\n\n  export function model<T>(name: string, schema?: Schema<T, any, any> | Schema<T & Document, any, any>, collection?: string, options?: CompileModelOptions): Model<T>;\n  export function model<T, U, TQueryHelpers = {}>(\n    name: string,\n    schema?: Schema<T, U, TQueryHelpers>,\n    collection?: string,\n    options?: CompileModelOptions\n  ): U;\n\n  /** Returns an array of model names created on this instance of Mongoose. */\n  export function modelNames(): Array<string>;\n\n  /** The node-mongodb-native driver Mongoose uses. */\n  export const mongo: typeof mongodb;\n\n  /**\n   * Mongoose uses this function to get the current time when setting\n   * [timestamps](/docs/guide.html#timestamps). You may stub out this function\n   * using a tool like [Sinon](https://www.npmjs.com/package/sinon) for testing.\n   */\n  export function now(): NativeDate;\n\n  /** Declares a global plugin executed on all Schemas. */\n  export function plugin(fn: (schema: Schema, opts?: any) => void, opts?: any): typeof mongoose;\n\n  /** Getter/setter around function for pluralizing collection names. */\n  export function pluralize(fn?: ((str: string) => string) | null): ((str: string) => string) | null;\n\n  /** Sets mongoose options */\n  export function set<K extends keyof MongooseOptions>(key: K, value: MongooseOptions[K]): typeof mongoose;\n\n  /**\n   * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions)\n   * for benefits like causal consistency, [retryable writes](https://docs.mongodb.com/manual/core/retryable-writes/),\n   * and [transactions](http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n   */\n  export function startSession(options?: mongodb.ClientSessionOptions): Promise<mongodb.ClientSession>;\n  export function startSession(options: mongodb.ClientSessionOptions, cb: Callback<mongodb.ClientSession>): void;\n\n  /** The Mongoose version */\n  export const version: string;\n\n  export type CastError = Error.CastError;\n\n  type Mongoose = typeof mongoose;\n\n  interface MongooseOptions {\n    /** true by default. Set to false to skip applying global plugins to child schemas */\n    applyPluginsToChildSchemas?: boolean;\n\n    /**\n     * false by default. Set to true to apply global plugins to discriminator schemas.\n     * This typically isn't necessary because plugins are applied to the base schema and\n     * discriminators copy all middleware, methods, statics, and properties from the base schema.\n     */\n    applyPluginsToDiscriminators?: boolean;\n\n    /**\n     * Set to `true` to make Mongoose call` Model.createCollection()` automatically when you\n     * create a model with `mongoose.model()` or `conn.model()`. This is useful for testing\n     * transactions, change streams, and other features that require the collection to exist.\n     */\n    autoCreate?: boolean;\n\n    /**\n     * true by default. Set to false to disable automatic index creation\n     * for all models associated with this Mongoose instance.\n     */\n    autoIndex?: boolean;\n\n    /** enable/disable mongoose's buffering mechanism for all connections and models */\n    bufferCommands?: boolean;\n\n    bufferTimeoutMS?: number;\n\n    /** false by default. Set to `true` to `clone()` all schemas before compiling into a model. */\n    cloneSchemas?: boolean;\n\n    /**\n     * If `true`, prints the operations mongoose sends to MongoDB to the console.\n     * If a writable stream is passed, it will log to that stream, without colorization.\n     * If a callback function is passed, it will receive the collection name, the method\n     * name, then all arguments passed to the method. For example, if you wanted to\n     * replicate the default logging, you could output from the callback\n     * `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n     */\n    debug?:\n      | boolean\n      | { color?: boolean; shell?: boolean }\n      | stream.Writable\n      | ((collectionName: string, methodName: string, ...methodArgs: any[]) => void);\n\n    /** If set, attaches [maxTimeMS](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/) to every query */\n    maxTimeMS?: number;\n\n    /**\n     * true by default. Mongoose adds a getter to MongoDB ObjectId's called `_id` that\n     * returns `this` for convenience with populate. Set this to false to remove the getter.\n     */\n    objectIdGetter?: boolean;\n\n    /**\n     * Set to `true` to default to overwriting models with the same name when calling\n     * `mongoose.model()`, as opposed to throwing an `OverwriteModelError`.\n     */\n    overwriteModels?: boolean;\n\n    /**\n     * If `false`, changes the default `returnOriginal` option to `findOneAndUpdate()`,\n     * `findByIdAndUpdate`, and `findOneAndReplace()` to false. This is equivalent to\n     * setting the `new` option to `true` for `findOneAndX()` calls by default. Read our\n     * `findOneAndUpdate()` [tutorial](https://mongoosejs.com/docs/tutorials/findoneandupdate.html)\n     * for more information.\n     */\n    returnOriginal?: boolean;\n\n    /**\n     * false by default. Set to true to enable [update validators](\n     * https://mongoosejs.com/docs/validation.html#update-validators\n     * ) for all validators by default.\n     */\n    runValidators?: boolean;\n\n    sanitizeFilter?: boolean;\n\n    sanitizeProjection?: boolean;\n\n    /**\n     * true by default. Set to false to opt out of Mongoose adding all fields that you `populate()`\n     * to your `select()`. The schema-level option `selectPopulatedPaths` overwrites this one.\n     */\n    selectPopulatedPaths?: boolean;\n\n    setDefaultsOnInsert?: boolean;\n\n    /** true by default, may be `false`, `true`, or `'throw'`. Sets the default strict mode for schemas. */\n    strict?: boolean | 'throw';\n\n    /**\n     * false by default, may be `false`, `true`, or `'throw'`. Sets the default\n     * [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery) mode for schemas.\n     */\n    strictQuery?: boolean | 'throw';\n\n    /**\n     * `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to\n     * `toJSON()`, for determining how Mongoose documents get serialized by `JSON.stringify()`\n     */\n    toJSON?: ToObjectOptions;\n\n    /** `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to `toObject()` */\n    toObject?: ToObjectOptions;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-interface\n  interface ClientSession extends mongodb.ClientSession { }\n\n  interface ConnectOptions extends mongodb.MongoClientOptions {\n    /** Set to false to [disable buffering](http://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection. */\n    bufferCommands?: boolean;\n    /** The name of the database you want to use. If not provided, Mongoose uses the database name from connection string. */\n    dbName?: string;\n    /** username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility. */\n    user?: string;\n    /** password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility. */\n    pass?: string;\n    /** Set to false to disable automatic index creation for all models associated with this connection. */\n    autoIndex?: boolean;\n    /** Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection. */\n    autoCreate?: boolean;\n  }\n\n  class Connection extends events.EventEmitter {\n    /** Returns a promise that resolves when this connection successfully connects to MongoDB */\n    asPromise(): Promise<this>;\n\n    /** Closes the connection */\n    close(callback: CallbackWithoutResult): void;\n    close(force: boolean, callback: CallbackWithoutResult): void;\n    close(force?: boolean): Promise<void>;\n\n    /** Retrieves a collection, creating it if not cached. */\n    collection(name: string, options?: mongodb.CreateCollectionOptions): Collection;\n\n    /** A hash of the collections associated with this connection */\n    collections: { [index: string]: Collection };\n\n    /** A hash of the global options that are associated with this connection */\n    config: any;\n\n    /** The mongodb.Db instance, set when the connection is opened */\n    db: mongodb.Db;\n\n    /**\n     * Helper for `createCollection()`. Will explicitly create the given collection\n     * with specified options. Used to create [capped collections](https://docs.mongodb.com/manual/core/capped-collections/)\n     * and [views](https://docs.mongodb.com/manual/core/views/) from mongoose.\n     */\n    createCollection(name: string, options?: mongodb.CreateCollectionOptions): Promise<mongodb.Collection>;\n    createCollection(name: string, cb: Callback<mongodb.Collection>): void;\n    createCollection(name: string, options: mongodb.CreateCollectionOptions, cb?: Callback<mongodb.Collection>): Promise<mongodb.Collection>;\n\n    /**\n     * Removes the model named `name` from this connection, if it exists. You can\n     * use this function to clean up any models you created in your tests to\n     * prevent OverwriteModelErrors.\n     */\n    deleteModel(name: string): this;\n\n    /**\n     * Helper for `dropCollection()`. Will delete the given collection, including\n     * all documents and indexes.\n     */\n    dropCollection(collection: string): Promise<void>;\n    dropCollection(collection: string, cb: CallbackWithoutResult): void;\n\n    /**\n     * Helper for `dropDatabase()`. Deletes the given database, including all\n     * collections, documents, and indexes.\n     */\n    dropDatabase(): Promise<void>;\n    dropDatabase(cb: CallbackWithoutResult): void;\n\n    /** Gets the value of the option `key`. Equivalent to `conn.options[key]` */\n    get(key: string): any;\n\n    /**\n     * Returns the [MongoDB driver `MongoClient`](http://mongodb.github.io/node-mongodb-native/3.5/api/MongoClient.html) instance\n     * that this connection uses to talk to MongoDB.\n     */\n    getClient(): mongodb.MongoClient;\n\n    /**\n     * The host name portion of the URI. If multiple hosts, such as a replica set,\n     * this will contain the first host name in the URI\n     */\n    host: string;\n\n    /**\n     * A number identifier for this connection. Used for debugging when\n     * you have [multiple connections](/docs/connections.html#multiple_connections).\n     */\n    id: number;\n\n    /**\n     * A [POJO](https://masteringjs.io/tutorials/fundamentals/pojo) containing\n     * a map from model names to models. Contains all models that have been\n     * added to this connection using [`Connection#model()`](/docs/api/connection.html#connection_Connection-model).\n     */\n    models: { [index: string]: Model<any> };\n\n    /** Defines or retrieves a model. */\n    model<T>(name: string, schema?: Schema<any>, collection?: string, options?: CompileModelOptions): Model<T>;\n    model<T, U, TQueryHelpers = {}>(\n      name: string,\n      schema?: Schema<T, U, TQueryHelpers>,\n      collection?: string,\n      options?: CompileModelOptions\n    ): U;\n\n    /** Returns an array of model names created on this connection. */\n    modelNames(): Array<string>;\n\n    /** The name of the database this connection points to. */\n    name: string;\n\n    /** Opens the connection with a URI using `MongoClient.connect()`. */\n    openUri(uri: string, options?: ConnectOptions): Promise<Connection>;\n    openUri(uri: string, callback: (err: CallbackError, conn?: Connection) => void): Connection;\n    openUri(uri: string, options: ConnectOptions, callback: (err: CallbackError, conn?: Connection) => void): Connection;\n\n    /** The password specified in the URI */\n    pass: string;\n\n    /**\n     * The port portion of the URI. If multiple hosts, such as a replica set,\n     * this will contain the port from the first host name in the URI.\n     */\n    port: number;\n\n    /** Declares a plugin executed on all schemas you pass to `conn.model()` */\n    plugin(fn: (schema: Schema, opts?: any) => void, opts?: any): Connection;\n\n    /** The plugins that will be applied to all models created on this connection. */\n    plugins: Array<any>;\n\n    /**\n     * Connection ready state\n     *\n     * - 0 = disconnected\n     * - 1 = connected\n     * - 2 = connecting\n     * - 3 = disconnecting\n     */\n    readyState: number;\n\n    /** Sets the value of the option `key`. Equivalent to `conn.options[key] = val` */\n    set(key: string, value: any): any;\n\n    /**\n     * Set the [MongoDB driver `MongoClient`](http://mongodb.github.io/node-mongodb-native/3.5/api/MongoClient.html) instance\n     * that this connection uses to talk to MongoDB. This is useful if you already have a MongoClient instance, and want to\n     * reuse it.\n     */\n    setClient(client: mongodb.MongoClient): this;\n\n    /**\n     * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions)\n     * for benefits like causal consistency, [retryable writes](https://docs.mongodb.com/manual/core/retryable-writes/),\n     * and [transactions](http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n     */\n    startSession(options?: mongodb.ClientSessionOptions): Promise<mongodb.ClientSession>;\n    startSession(options: mongodb.ClientSessionOptions, cb: Callback<mongodb.ClientSession>): void;\n\n    /**\n     * Makes the indexes in MongoDB match the indexes defined in every model's\n     * schema. This function will drop any indexes that are not defined in\n     * the model's schema except the `_id` index, and build any indexes that\n     * are in your schema but not in MongoDB.\n     */\n    syncIndexes(options?: Record<string, unknown>): Promise<Array<string>>;\n    syncIndexes(options: Record<string, unknown> | null, callback: Callback<Array<string>>): void;\n\n    /**\n     * _Requires MongoDB >= 3.6.0._ Executes the wrapped async function\n     * in a transaction. Mongoose will commit the transaction if the\n     * async function executes successfully and attempt to retry if\n     * there was a retriable error.\n     */\n    transaction(fn: (session: mongodb.ClientSession) => Promise<any>): Promise<any>;\n\n    /** Switches to a different database using the same connection pool. */\n    useDb(name: string, options?: { useCache?: boolean, noListener?: boolean }): Connection;\n\n    /** The username specified in the URI */\n    user: string;\n\n    /** Watches the entire underlying database for changes. Similar to [`Model.watch()`](/docs/api/model.html#model_Model.watch). */\n    watch<ResultType = any>(pipeline?: Array<any>, options?: mongodb.ChangeStreamOptions): mongodb.ChangeStream<ResultType>;\n  }\n\n   /*\n   * section collection.js\n   * http://mongoosejs.com/docs/api.html#collection-js\n   */\n  interface CollectionBase extends mongodb.Collection {\n    /*\n      * Abstract methods. Some of these are already defined on the\n      * mongodb.Collection interface so they've been commented out.\n      */\n    ensureIndex(...args: any[]): any;\n    findAndModify(...args: any[]): any;\n    getIndexes(...args: any[]): any;\n\n    /** The collection name */\n    collectionName: string;\n    /** The Connection instance */\n    conn: Connection;\n    /** The collection name */\n    name: string;\n  }\n\n  /*\n   * section drivers/node-mongodb-native/collection.js\n   * http://mongoosejs.com/docs/api.html#drivers-node-mongodb-native-collection-js\n   */\n  let Collection: Collection;\n  interface Collection extends CollectionBase {\n    /**\n     * Collection constructor\n     * @param name name of the collection\n     * @param conn A MongooseConnection instance\n     * @param opts optional collection options\n     */\n    // eslint-disable-next-line @typescript-eslint/no-misused-new\n    new(name: string, conn: Connection, opts?: any): Collection;\n    /** Formatter for debug print args */\n    $format(arg: any): string;\n    /** Debug print helper */\n    $print(name: any, i: any, args: any[]): void;\n    /** Retrieves information about this collections indexes. */\n    getIndexes(): any;\n  }\n\n  class Document<T = any, TQueryHelpers = any, DocType = any> {\n    constructor(doc?: any);\n\n    /** This documents _id. */\n    _id?: T;\n\n    /** This documents __v. */\n    __v?: any;\n\n    /* Get all subdocs (by bfs) */\n    $getAllSubdocs(): Document[];\n\n    /** Don't run validation on this path or persist changes to this path. */\n    $ignore(path: string): void;\n\n    /** Checks if a path is set to its default. */\n    $isDefault(path: string): boolean;\n\n    /** Getter/setter, determines whether the document was removed or not. */\n    $isDeleted(val?: boolean): boolean;\n\n    /** Returns an array of all populated documents associated with the query */\n    $getPopulatedDocs(): Document[];\n\n    /**\n     * Returns true if the given path is nullish or only contains empty objects.\n     * Useful for determining whether this subdoc will get stripped out by the\n     * [minimize option](/docs/guide.html#minimize).\n     */\n    $isEmpty(path: string): boolean;\n\n    /** Checks if a path is invalid */\n    $isValid(path: string): boolean;\n\n    /**\n     * Empty object that you can use for storing properties on the document. This\n     * is handy for passing data to middleware without conflicting with Mongoose\n     * internals.\n     */\n    $locals: Record<string, unknown>;\n\n    /** Marks a path as valid, removing existing validation errors. */\n    $markValid(path: string): void;\n\n    /**\n     * A string containing the current operation that Mongoose is executing\n     * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n     */\n    $op: string | null;\n\n    /**\n     * Getter/setter around the session associated with this document. Used to\n     * automatically set `session` if you `save()` a doc that you got from a\n     * query with an associated session.\n     */\n    $session(session?: mongodb.ClientSession | null): mongodb.ClientSession;\n\n    /** Alias for `set()`, used internally to avoid conflicts */\n    $set(path: string, val: any, options?: any): this;\n    $set(path: string, val: any, type: any, options?: any): this;\n    $set(value: any): this;\n\n    /** Set this property to add additional query filters when Mongoose saves this document and `isNew` is false. */\n    $where: Record<string, unknown>;\n\n    /** If this is a discriminator model, `baseModelName` is the name of the base model. */\n    baseModelName?: string;\n\n    /** Collection the model uses. */\n    collection: Collection;\n\n    /** Connection the model uses. */\n    db: Connection;\n\n    /** Removes this document from the db. */\n    delete(options?: QueryOptions): QueryWithHelpers<any, this, TQueryHelpers>;\n    delete(options: QueryOptions, cb?: Callback): void;\n    delete(cb: Callback): void;\n\n    /** Removes this document from the db. */\n    deleteOne(options?: QueryOptions): QueryWithHelpers<any, this, TQueryHelpers>;\n    deleteOne(options: QueryOptions, cb?: Callback): void;\n    deleteOne(cb: Callback): void;\n\n    /**\n     * Takes a populated field and returns it to its unpopulated state. If called with\n     * no arguments, then all populated fields are returned to their unpopulated state.\n     */\n    depopulate(path?: string | string[]): this;\n\n    /**\n     * Returns the list of paths that have been directly modified. A direct\n     * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n     * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n     */\n    directModifiedPaths(): Array<string>;\n\n    /**\n     * Returns true if this document is equal to another document.\n     *\n     * Documents are considered equal when they have matching `_id`s, unless neither\n     * document has an `_id`, in which case this function falls back to using\n     * `deepEqual()`.\n     */\n    equals(doc: Document<T>): boolean;\n\n    /** Hash containing current validation errors. */\n    errors?: Error.ValidationError;\n\n    /** Returns the value of a path. */\n    get(path: string, type?: any, options?: any): any;\n\n    /**\n     * Returns the changes that happened to the document\n     * in the format that will be sent to MongoDB.\n     */\n    getChanges(): UpdateQuery<this>;\n\n    /** The string version of this documents _id. */\n    id?: any;\n\n    /** Signal that we desire an increment of this documents version. */\n    increment(): this;\n\n    /**\n     * Initializes the document without setters or marking anything modified.\n     * Called internally after a document is returned from mongodb. Normally,\n     * you do **not** need to call this function on your own.\n     */\n    init(obj: any, opts?: any, cb?: Callback<this>): this;\n\n    /** Marks a path as invalid, causing validation to fail. */\n    invalidate(path: string, errorMsg: string | NativeError, value?: any, kind?: string): NativeError | null;\n\n    /** Returns true if `path` was directly set and modified, else false. */\n    isDirectModified(path: string): boolean;\n\n    /** Checks if `path` was explicitly selected. If no projection, always returns true. */\n    isDirectSelected(path: string): boolean;\n\n    /** Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since. */\n    isInit(path: string): boolean;\n\n    /**\n     * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n     * in this document is modified.\n     */\n    isModified(path?: string | Array<string>): boolean;\n\n    /** Boolean flag specifying if the document is new. */\n    isNew: boolean;\n\n    /** Checks if `path` was selected in the source query which initialized this document. */\n    isSelected(path: string): boolean;\n\n    /** Marks the path as having pending changes to write to the db. */\n    markModified(path: string, scope?: any): void;\n\n    /** Returns the list of paths that have been modified. */\n    modifiedPaths(options?: { includeChildren?: boolean }): Array<string>;\n\n    /** The name of the model */\n    modelName: string;\n\n    /**\n     * Overwrite all values in this document with the values of `obj`, except\n     * for immutable properties. Behaves similarly to `set()`, except for it\n     * unsets all properties that aren't in `obj`.\n     */\n    overwrite(obj: AnyObject): this;\n\n    /**\n     * If this document is a subdocument or populated document, returns the\n     * document's parent. Returns undefined otherwise.\n     */\n    $parent(): Document | undefined;\n\n    /** Populates document references. */\n    populate<Paths = {}>(path: string | PopulateOptions | (string | PopulateOptions)[]): Promise<this & Paths>;\n    populate<Paths = {}>(path: string | PopulateOptions | (string | PopulateOptions)[], callback: Callback<this & Paths>): void;\n    populate<Paths = {}>(path: string, names: string): Promise<this & Paths>;\n    populate<Paths = {}>(path: string, names: string, callback: Callback<this & Paths>): void;\n\n    /** Gets _id(s) used during population of the given `path`. If the path was not populated, returns `undefined`. */\n    populated(path: string): any;\n\n    /** Removes this document from the db. */\n    remove(options?: QueryOptions): Promise<this>;\n    remove(options?: QueryOptions, cb?: Callback): void;\n\n    /** Sends a replaceOne command with this document `_id` as the query selector. */\n    replaceOne(replacement?: AnyObject, options?: QueryOptions | null, callback?: Callback): Query<any, this>;\n    replaceOne(replacement?: AnyObject, options?: QueryOptions | null, callback?: Callback): Query<any, this>;\n\n    /** Saves this document by inserting a new document into the database if [document.isNew](/docs/api.html#document_Document-isNew) is `true`, or sends an [updateOne](/docs/api.html#document_Document-updateOne) operation with just the modified paths if `isNew` is `false`. */\n    save(options?: SaveOptions): Promise<this>;\n    save(options?: SaveOptions, fn?: Callback<this>): void;\n    save(fn?: Callback<this>): void;\n\n    /** The document's schema. */\n    schema: Schema;\n\n    /** Sets the value of a path, or many paths. */\n    set(path: string, val: any, options?: any): this;\n    set(path: string, val: any, type: any, options?: any): this;\n    set(value: any): this;\n\n    /** The return value of this method is used in calls to JSON.stringify(doc). */\n    toJSON(options: ToObjectOptions & { flattenMaps: false }): LeanDocument<this>;\n    toJSON(options?: ToObjectOptions): FlattenMaps<LeanDocument<this>>;\n    toJSON<T = FlattenMaps<DocType>>(options?: ToObjectOptions): T;\n\n    /** Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)). */\n    toObject(options?: ToObjectOptions): LeanDocument<this>;\n    toObject<T = DocType>(options?: ToObjectOptions): T;\n\n    /** Clears the modified state on the specified path. */\n    unmarkModified(path: string): void;\n\n    /** Sends an update command with this document `_id` as the query selector. */\n    update(update?: UpdateQuery<this> | UpdateWithAggregationPipeline, options?: QueryOptions | null, callback?: Callback): Query<any, this>;\n\n    /** Sends an updateOne command with this document `_id` as the query selector. */\n    updateOne(update?: UpdateQuery<this> | UpdateWithAggregationPipeline, options?: QueryOptions | null, callback?: Callback): Query<any, this>;\n\n    /** Executes registered validation rules for this document. */\n    validate(options:{ pathsToSkip?: pathsToSkip }): Promise<void>;\n    validate(pathsToValidate?: pathsToValidate, options?: any): Promise<void>;\n    validate(callback: CallbackWithoutResult): void;\n    validate(pathsToValidate: pathsToValidate, callback: CallbackWithoutResult): void;\n    validate(pathsToValidate: pathsToValidate, options: any, callback: CallbackWithoutResult): void;\n\n    /** Executes registered validation rules (skipping asynchronous validators) for this document. */\n    validateSync(options:{pathsToSkip?: pathsToSkip, [k:string]: any }): Error.ValidationError | null;\n    validateSync(pathsToValidate?: Array<string>, options?: any): Error.ValidationError | null;\n  }\n\n  /** A list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list. */\n  type pathsToValidate = string[] | string;\n  /** A list of paths to skip. If set, Mongoose will validate every modified path that is not in this list. */\n  type pathsToSkip = string[] | string;\n\n  interface AcceptsDiscriminator {\n    /** Adds a discriminator type. */\n    discriminator<D>(name: string | number, schema: Schema, value?: string | number | ObjectId): Model<D>;\n    discriminator<T, U>(name: string | number, schema: Schema<T, U>, value?: string | number | ObjectId): U;\n  }\n\n  type AnyKeys<T> = { [P in keyof T]?: T[P] | any };\n  interface AnyObject { [k: string]: any }\n\n  type Require_id<T> = T extends { _id?: any } ? (T & { _id: T['_id'] }) : (T & { _id: Types.ObjectId });\n\n  export type HydratedDocument<DocType, TMethods = {}, TVirtuals = {}> = DocType extends Document ? Require_id<DocType> : (Document<unknown, any, DocType> & Require_id<DocType> & TVirtuals & TMethods);\n\n  interface IndexesDiff {\n    /** Indexes that would be created in mongodb. */\n    toCreate: Array<any>\n    /** Indexes that would be dropped in mongodb. */\n    toDrop: Array<any>\n  }\n\n  export const Model: Model<any>;\n  interface Model<T, TQueryHelpers = {}, TMethods = {}, TVirtuals = {}> extends NodeJS.EventEmitter, AcceptsDiscriminator {\n    new<DocType = AnyKeys<T> & AnyObject>(doc?: DocType, fields?: any | null, options?: boolean | AnyObject): HydratedDocument<T, TMethods, TVirtuals>;\n\n    aggregate<R = any>(pipeline?: PipelineStage[], options?: mongodb.AggregateOptions, callback?: Callback<R[]>): Aggregate<Array<R>>;\n    aggregate<R = any>(pipeline: PipelineStage[], cb: Function): Aggregate<Array<R>>;\n\n    /** Base Mongoose instance the model uses. */\n    base: typeof mongoose;\n\n    /**\n     * If this is a discriminator model, `baseModelName` is the name of\n     * the base model.\n     */\n    baseModelName: string | undefined;\n\n    /**\n     * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n     * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n     * command. This is faster than sending multiple independent operations (e.g.\n     * if you use `create()`) because with `bulkWrite()` there is only one network\n     * round trip to the MongoDB server.\n     */\n    bulkWrite(writes: Array<any>, options?: mongodb.BulkWriteOptions): Promise<mongodb.BulkWriteResult>;\n    bulkWrite(writes: Array<any>, options?: mongodb.BulkWriteOptions, cb?: Callback<mongodb.BulkWriteResult>): void;\n\n    /**\n     * Sends multiple `save()` calls in a single `bulkWrite()`. This is faster than\n     * sending multiple `save()` calls because with `bulkSave()` there is only one\n     * network round trip to the MongoDB server.\n     */\n    bulkSave(documents: Array<Document>): Promise<mongodb.BulkWriteResult>;\n\n    /** Collection the model uses. */\n    collection: Collection;\n\n    /** Creates a `count` query: counts the number of documents that match `filter`. */\n    count(callback?: Callback<number>): QueryWithHelpers<number, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    count(filter: FilterQuery<T>, callback?: Callback<number>): QueryWithHelpers<number, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `countDocuments` query: counts the number of documents that match `filter`. */\n    countDocuments(callback?: Callback<number>): QueryWithHelpers<number, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    countDocuments(filter: FilterQuery<T>, options?: QueryOptions, callback?: Callback<number>): QueryWithHelpers<number, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a new document or documents */\n    create(docs: (AnyKeys<T> | AnyObject)[], options?: SaveOptions): Promise<HydratedDocument<T, TMethods, TVirtuals>[]>;\n    create(docs: (AnyKeys<T> | AnyObject)[], callback: Callback<HydratedDocument<T, TMethods, TVirtuals>[]>): void;\n    create(doc: AnyKeys<T> | AnyObject): Promise<HydratedDocument<T, TMethods, TVirtuals>>;\n    create(doc: AnyKeys<T> | AnyObject, callback: Callback<HydratedDocument<T, TMethods, TVirtuals>>): void;\n    create<DocContents = AnyKeys<T>>(docs: DocContents[], options?: SaveOptions): Promise<HydratedDocument<T, TMethods, TVirtuals>[]>;\n    create<DocContents = AnyKeys<T>>(docs: DocContents[], callback: Callback<HydratedDocument<T, TMethods, TVirtuals>[]>): void;\n    create<DocContents = AnyKeys<T>>(doc: DocContents): Promise<HydratedDocument<T, TMethods, TVirtuals>>;\n    create<DocContents = AnyKeys<T>>(...docs: DocContents[]): Promise<HydratedDocument<T, TMethods, TVirtuals>[]>;\n    create<DocContents = AnyKeys<T>>(doc: DocContents, callback: Callback<HydratedDocument<T, TMethods, TVirtuals>>): void;\n\n    /**\n     * Create the collection for this model. By default, if no indexes are specified,\n     * mongoose will not create the collection for the model until any documents are\n     * created. Use this method to create the collection explicitly.\n     */\n    createCollection(options?: mongodb.CreateCollectionOptions): Promise<mongodb.Collection>;\n    createCollection(options: mongodb.CreateCollectionOptions | null, callback: Callback<mongodb.Collection>): void;\n\n    /**\n     * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#createIndex)\n     * function.\n     */\n    createIndexes(callback?: CallbackWithoutResult): Promise<void>;\n    createIndexes(options?: any, callback?: CallbackWithoutResult): Promise<void>;\n\n    /** Connection the model uses. */\n    db: Connection;\n\n    /**\n     * Deletes all of the documents that match `conditions` from the collection.\n     * Behaves like `remove()`, but deletes all documents that match `conditions`\n     * regardless of the `single` option.\n     */\n    deleteMany(filter?: FilterQuery<T>, options?: QueryOptions, callback?: CallbackWithoutResult): QueryWithHelpers<mongodb.DeleteResult, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    deleteMany(filter: FilterQuery<T>, callback: CallbackWithoutResult): QueryWithHelpers<mongodb.DeleteResult, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    deleteMany(callback: CallbackWithoutResult): QueryWithHelpers<mongodb.DeleteResult, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /**\n     * Deletes the first document that matches `conditions` from the collection.\n     * Behaves like `remove()`, but deletes at most one document regardless of the\n     * `single` option.\n     */\n    deleteOne(filter?: FilterQuery<T>, options?: QueryOptions, callback?: CallbackWithoutResult): QueryWithHelpers<mongodb.DeleteResult, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    deleteOne(filter: FilterQuery<T>, callback: CallbackWithoutResult): QueryWithHelpers<mongodb.DeleteResult, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    deleteOne(callback: CallbackWithoutResult): QueryWithHelpers<mongodb.DeleteResult, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /**\n     * Sends `createIndex` commands to mongo for each index declared in the schema.\n     * The `createIndex` commands are sent in series.\n     */\n    ensureIndexes(callback?: CallbackWithoutResult): Promise<void>;\n    ensureIndexes(options?: any, callback?: CallbackWithoutResult): Promise<void>;\n\n    /**\n     * Event emitter that reports any errors that occurred. Useful for global error\n     * handling.\n     */\n    events: NodeJS.EventEmitter;\n\n    /**\n     * Finds a single document by its _id field. `findById(id)` is almost*\n     * equivalent to `findOne({ _id: id })`. If you want to query by a document's\n     * `_id`, use `findById()` instead of `findOne()`.\n     */\n    findById(id: any, projection?: any | null, options?: QueryOptions | null, callback?: Callback<HydratedDocument<T, TMethods, TVirtuals> | null>): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals> | null, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Finds one document. */\n    findOne(filter?: FilterQuery<T>, projection?: any | null, options?: QueryOptions | null, callback?: Callback<HydratedDocument<T, TMethods, TVirtuals> | null>): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals> | null, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /**\n     * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n     * The document returned has no paths marked as modified initially.\n     */\n    hydrate(obj: any): HydratedDocument<T, TMethods, TVirtuals>;\n\n    /**\n     * This function is responsible for building [indexes](https://docs.mongodb.com/manual/indexes/),\n     * unless [`autoIndex`](http://mongoosejs.com/docs/guide.html#autoIndex) is turned off.\n     * Mongoose calls this function automatically when a model is created using\n     * [`mongoose.model()`](/docs/api.html#mongoose_Mongoose-model) or\n     * [`connection.model()`](/docs/api.html#connection_Connection-model), so you\n     * don't need to call it.\n     */\n    init(callback?: CallbackWithoutResult): Promise<HydratedDocument<T, TMethods, TVirtuals>>;\n\n    /** Inserts one or more new documents as a single `insertMany` call to the MongoDB server. */\n    insertMany(docs: Array<AnyKeys<T> | AnyObject>, options: InsertManyOptions & { rawResult: true }): Promise<InsertManyResult>;\n    insertMany(docs: Array<AnyKeys<T> | AnyObject>, options?: InsertManyOptions): Promise<Array<HydratedDocument<T, TMethods, TVirtuals>>>;\n    insertMany(doc: AnyKeys<T> | AnyObject, options: InsertManyOptions & { rawResult: true }): Promise<InsertManyResult>;\n    insertMany(doc: AnyKeys<T> | AnyObject, options?: InsertManyOptions): Promise<HydratedDocument<T, TMethods, TVirtuals>[]>;\n    insertMany(doc: AnyKeys<T> | AnyObject, options?: InsertManyOptions, callback?: Callback<HydratedDocument<T, TMethods, TVirtuals>[] | InsertManyResult>): void;\n    insertMany(docs: Array<AnyKeys<T> | AnyObject>, options?: InsertManyOptions, callback?: Callback<Array<HydratedDocument<T, TMethods, TVirtuals>> | InsertManyResult>): void;\n\n    /**\n     * Lists the indexes currently defined in MongoDB. This may or may not be\n     * the same as the indexes defined in your schema depending on whether you\n     * use the [`autoIndex` option](/docs/guide.html#autoIndex) and if you\n     * build indexes manually.\n     */\n    listIndexes(callback: Callback<Array<any>>): void;\n    listIndexes(): Promise<Array<any>>;\n\n    /** The name of the model */\n    modelName: string;\n\n    /** Populates document references. */\n    populate(docs: Array<any>, options: PopulateOptions | Array<PopulateOptions> | string,\n      callback?: Callback<(HydratedDocument<T, TMethods, TVirtuals>)[]>): Promise<Array<HydratedDocument<T, TMethods, TVirtuals>>>;\n    populate(doc: any, options: PopulateOptions | Array<PopulateOptions> | string,\n      callback?: Callback<HydratedDocument<T, TMethods, TVirtuals>>): Promise<HydratedDocument<T, TMethods, TVirtuals>>;\n\n    /**\n     * Makes the indexes in MongoDB match the indexes defined in this model's\n     * schema. This function will drop any indexes that are not defined in\n     * the model's schema except the `_id` index, and build any indexes that\n     * are in your schema but not in MongoDB.\n     */\n    syncIndexes(options?: Record<string, unknown>): Promise<Array<string>>;\n    syncIndexes(options: Record<string, unknown> | null, callback: Callback<Array<string>>): void;\n\n    /**\n     * Does a dry-run of Model.syncIndexes(), meaning that\n     * the result of this function would be the result of\n     * Model.syncIndexes().\n     */\n    diffIndexes(options?: Record<string, unknown>): Promise<IndexesDiff>\n    diffIndexes(options: Record<string, unknown> | null, callback: (err: CallbackError, diff: IndexesDiff) => void): void\n\n    /**\n     * Starts a [MongoDB session](https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions)\n     * for benefits like causal consistency, [retryable writes](https://docs.mongodb.com/manual/core/retryable-writes/),\n     * and [transactions](http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n     * */\n    startSession(options?: mongodb.ClientSessionOptions, cb?: Callback<mongodb.ClientSession>): Promise<mongodb.ClientSession>;\n\n    /** Casts and validates the given object against this model's schema, passing the given `context` to custom validators. */\n    validate(callback?: CallbackWithoutResult): Promise<void>;\n    validate(optional: any, callback?: CallbackWithoutResult): Promise<void>;\n    validate(optional: any, pathsToValidate: string[], callback?: CallbackWithoutResult): Promise<void>;\n\n    /** Watches the underlying collection for changes using [MongoDB change streams](https://docs.mongodb.com/manual/changeStreams/). */\n    watch<ResultType = any>(pipeline?: Array<Record<string, unknown>>, options?: mongodb.ChangeStreamOptions): mongodb.ChangeStream<ResultType>;\n\n    /** Adds a `$where` clause to this query */\n    $where(argument: string | Function): QueryWithHelpers<Array<HydratedDocument<T, TMethods, TVirtuals>>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Registered discriminators for this model. */\n    discriminators: { [name: string]: Model<any> } | undefined;\n\n    /** Translate any aliases fields/conditions so the final query or document object is pure */\n    translateAliases(raw: any): any;\n\n    /** Creates a `distinct` query: returns the distinct values of the given `field` that match `filter`. */\n    distinct(field: string, filter?: FilterQuery<T>, callback?: Callback<number>): QueryWithHelpers<Array<any>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `estimatedDocumentCount` query: counts the number of documents in the collection. */\n    estimatedDocumentCount(options?: QueryOptions, callback?: Callback<number>): QueryWithHelpers<number, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /**\n     * Returns true if at least one document exists in the database that matches\n     * the given `filter`, and false otherwise.\n     */\n    exists(filter: FilterQuery<T>): Promise<boolean>;\n    exists(filter: FilterQuery<T>, callback: Callback<boolean>): void;\n\n    /** Creates a `find` query: gets a list of documents that match `filter`. */\n    find(callback?: Callback<HydratedDocument<T, TMethods, TVirtuals>[]>): QueryWithHelpers<Array<HydratedDocument<T, TMethods, TVirtuals>>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    find(filter: FilterQuery<T>, callback?: Callback<T[]>): QueryWithHelpers<Array<HydratedDocument<T, TMethods, TVirtuals>>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    find(filter: FilterQuery<T>, projection?: any | null, options?: QueryOptions | null, callback?: Callback<HydratedDocument<T, TMethods, TVirtuals>[]>): QueryWithHelpers<Array<HydratedDocument<T, TMethods, TVirtuals>>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `findByIdAndDelete` query, filtering by the given `_id`. */\n    findByIdAndDelete(id?: mongodb.ObjectId | any, options?: QueryOptions | null, callback?: (err: CallbackError, doc: HydratedDocument<T, TMethods, TVirtuals> | null, res: any) => void): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals> | null, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `findByIdAndRemove` query, filtering by the given `_id`. */\n    findByIdAndRemove(id?: mongodb.ObjectId | any, options?: QueryOptions | null, callback?: (err: CallbackError, doc: HydratedDocument<T, TMethods, TVirtuals> | null, res: any) => void): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals> | null, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `findOneAndUpdate` query, filtering by the given `_id`. */\n    findByIdAndUpdate(id: mongodb.ObjectId | any, update: UpdateQuery<T>, options: QueryOptions & { rawResult: true }, callback?: (err: CallbackError, doc: any, res: any) => void): QueryWithHelpers<mongodb.ModifyResult<HydratedDocument<T, TMethods, TVirtuals>>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    findByIdAndUpdate(id: mongodb.ObjectId | any, update: UpdateQuery<T>, options: QueryOptions & { upsert: true } & ReturnsNewDoc, callback?: (err: CallbackError, doc: HydratedDocument<T, TMethods, TVirtuals>, res: any) => void): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    findByIdAndUpdate(id?: mongodb.ObjectId | any, update?: UpdateQuery<T>, options?: QueryOptions | null, callback?: (err: CallbackError, doc: HydratedDocument<T, TMethods, TVirtuals> | null, res: any) => void): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals> | null, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    findByIdAndUpdate(id: mongodb.ObjectId | any, update: UpdateQuery<T>, callback: (err: CallbackError, doc: HydratedDocument<T, TMethods, TVirtuals> | null, res: any) => void): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals> | null, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `findOneAndDelete` query: atomically finds the given document, deletes it, and returns the document as it was before deletion. */\n    findOneAndDelete(filter?: FilterQuery<T>, options?: QueryOptions | null, callback?: (err: CallbackError, doc: HydratedDocument<T, TMethods, TVirtuals> | null, res: any) => void): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals> | null, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `findOneAndRemove` query: atomically finds the given document and deletes it. */\n    findOneAndRemove(filter?: FilterQuery<T>, options?: QueryOptions | null, callback?: (err: CallbackError, doc: HydratedDocument<T, TMethods, TVirtuals> | null, res: any) => void): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals> | null, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `findOneAndReplace` query: atomically finds the given document and replaces it with `replacement`. */\n    findOneAndReplace(filter: FilterQuery<T>, replacement: T | AnyObject, options: QueryOptions & { upsert: true } & ReturnsNewDoc, callback?: (err: CallbackError, doc: HydratedDocument<T, TMethods, TVirtuals>, res: any) => void): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    findOneAndReplace(filter?: FilterQuery<T>, replacement?: T | AnyObject, options?: QueryOptions | null, callback?: (err: CallbackError, doc: HydratedDocument<T, TMethods, TVirtuals> | null, res: any) => void): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals> | null, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `findOneAndUpdate` query: atomically find the first document that matches `filter` and apply `update`. */\n    findOneAndUpdate(filter: FilterQuery<T>, update: UpdateQuery<T>, options: QueryOptions & { rawResult: true }, callback?: (err: CallbackError, doc: any, res: any) => void): QueryWithHelpers<mongodb.ModifyResult<HydratedDocument<T, TMethods, TVirtuals>>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    findOneAndUpdate(filter: FilterQuery<T>, update: UpdateQuery<T>, options: QueryOptions & { upsert: true } & ReturnsNewDoc, callback?: (err: CallbackError, doc: HydratedDocument<T, TMethods, TVirtuals>, res: any) => void): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    findOneAndUpdate(filter?: FilterQuery<T>, update?: UpdateQuery<T>, options?: QueryOptions | null, callback?: (err: CallbackError, doc: T | null, res: any) => void): QueryWithHelpers<HydratedDocument<T, TMethods, TVirtuals> | null, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    geoSearch(filter?: FilterQuery<T>, options?: GeoSearchOptions, callback?: Callback<Array<HydratedDocument<T, TMethods, TVirtuals>>>): QueryWithHelpers<Array<HydratedDocument<T, TMethods, TVirtuals>>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Executes a mapReduce command. */\n    mapReduce<Key, Value>(\n      o: MapReduceOptions<T, Key, Value>,\n      callback?: Callback\n    ): Promise<any>;\n\n    remove(filter?: any, callback?: CallbackWithoutResult): QueryWithHelpers<any, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `replaceOne` query: finds the first document that matches `filter` and replaces it with `replacement`. */\n    replaceOne(filter?: FilterQuery<T>, replacement?: T | AnyObject, options?: QueryOptions | null, callback?: Callback): QueryWithHelpers<any, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    replaceOne(filter?: FilterQuery<T>, replacement?: T | AnyObject, options?: QueryOptions | null, callback?: Callback): QueryWithHelpers<any, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Schema the model uses. */\n    schema: Schema<T>;\n\n    /**\n     * @deprecated use `updateOne` or `updateMany` instead.\n     * Creates a `update` query: updates one or many documents that match `filter` with `update`, based on the `multi` option.\n     */\n    update(filter?: FilterQuery<T>, update?: UpdateQuery<T> | UpdateWithAggregationPipeline, options?: QueryOptions | null, callback?: Callback): QueryWithHelpers<UpdateWriteOpResult, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `updateMany` query: updates all documents that match `filter` with `update`. */\n    updateMany(filter?: FilterQuery<T>, update?: UpdateQuery<T> | UpdateWithAggregationPipeline, options?: QueryOptions | null, callback?: Callback): QueryWithHelpers<UpdateWriteOpResult, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a `updateOne` query: updates the first document that matches `filter` with `update`. */\n    updateOne(filter?: FilterQuery<T>, update?: UpdateQuery<T> | UpdateWithAggregationPipeline, options?: QueryOptions | null, callback?: Callback): QueryWithHelpers<UpdateWriteOpResult, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n\n    /** Creates a Query, applies the passed conditions, and returns the Query. */\n    where(path: string, val?: any): QueryWithHelpers<Array<HydratedDocument<T, TMethods, TVirtuals>>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    where(obj: object): QueryWithHelpers<Array<HydratedDocument<T, TMethods, TVirtuals>>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n    where(): QueryWithHelpers<Array<HydratedDocument<T, TMethods, TVirtuals>>, HydratedDocument<T, TMethods, TVirtuals>, TQueryHelpers, T>;\n  }\n\n  type UpdateWriteOpResult = mongodb.UpdateResult;\n\n  interface QueryOptions {\n    arrayFilters?: { [key: string]: any }[];\n    batchSize?: number;\n    collation?: mongodb.CollationOptions;\n    comment?: any;\n    context?: string;\n    explain?: any;\n    fields?: any | string;\n    hint?: any;\n    /**\n     * If truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document.\n     */\n    lean?: boolean | any;\n    limit?: number;\n    maxTimeMS?: number;\n    maxscan?: number;\n    multi?: boolean;\n    multipleCastError?: boolean;\n    /**\n     * By default, `findOneAndUpdate()` returns the document as it was **before**\n     * `update` was applied. If you set `new: true`, `findOneAndUpdate()` will\n     * instead give you the object after `update` was applied.\n     */\n    new?: boolean;\n    overwrite?: boolean;\n    overwriteDiscriminatorKey?: boolean;\n    populate?: string | string[] | PopulateOptions | PopulateOptions[];\n    projection?: any;\n    /**\n     * if true, returns the raw result from the MongoDB driver\n     */\n    rawResult?: boolean;\n    readPreference?: string | mongodb.ReadPreferenceMode;\n    /**\n     * An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.\n     */\n    returnOriginal?: boolean;\n    /**\n     * Another alias for the `new` option. `returnOriginal` is deprecated so this should be used.\n     */\n    returnDocument?: string;\n    runValidators?: boolean;\n    /* Set to `true` to automatically sanitize potentially unsafe user-generated query projections */\n    sanitizeProjection?: boolean;\n    /**\n     * Set to `true` to automatically sanitize potentially unsafe query filters by stripping out query selectors that\n     * aren't explicitly allowed using `mongoose.trusted()`.\n     */\n    sanitizeFilter?: boolean;\n    /** The session associated with this query. */\n    session?: mongodb.ClientSession;\n    setDefaultsOnInsert?: boolean;\n    skip?: number;\n    snapshot?: any;\n    sort?: any;\n    /** overwrites the schema's strict mode option */\n    strict?: boolean | string;\n    /**\n     * equal to `strict` by default, may be `false`, `true`, or `'throw'`. Sets the default\n     * [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery) mode for schemas.\n     */\n    strictQuery?: boolean | 'throw';\n    tailable?: number;\n    /**\n     * If set to `false` and schema-level timestamps are enabled,\n     * skip timestamps for this update. Note that this allows you to overwrite\n     * timestamps. Does nothing if schema-level timestamps are not set.\n     */\n    timestamps?: boolean;\n    upsert?: boolean;\n    writeConcern?: any;\n\n    [other: string]: any;\n  }\n\n  type MongooseQueryOptions = Pick<QueryOptions, 'populate' | 'lean' | 'strict' | 'sanitizeProjection' | 'sanitizeFilter'>;\n\n  interface SaveOptions {\n    checkKeys?: boolean;\n    j?: boolean;\n    safe?: boolean | WriteConcern;\n    session?: ClientSession | null;\n    timestamps?: boolean;\n    validateBeforeSave?: boolean;\n    validateModifiedOnly?: boolean;\n    w?: number | string;\n    wtimeout?: number;\n  }\n\n  interface WriteConcern {\n    j?: boolean;\n    w?: number | 'majority' | TagSet;\n    wtimeout?: number;\n  }\n\n  interface TagSet {\n    [k: string]: string;\n  }\n\n  interface InsertManyOptions {\n    limit?: number;\n    rawResult?: boolean;\n    ordered?: boolean;\n    lean?: boolean;\n    session?: mongodb.ClientSession;\n    populate?: string | string[] | PopulateOptions | PopulateOptions[];\n  }\n\n  interface InsertManyResult extends mongodb.InsertManyResult {\n    mongoose?: { validationErrors?: Array<Error.CastError | Error.ValidatorError> }\n  }\n\n  interface MapReduceOptions<T, Key, Val> {\n    map: Function | string;\n    reduce: (key: Key, vals: T[]) => Val;\n    /** query filter object. */\n    query?: any;\n    /** sort input objects using this key */\n    sort?: any;\n    /** max number of documents */\n    limit?: number;\n    /** keep temporary data default: false */\n    keeptemp?: boolean;\n    /** finalize function */\n    finalize?: (key: Key, val: Val) => Val;\n    /** scope variables exposed to map/reduce/finalize during execution */\n    scope?: any;\n    /** it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X default: false */\n    jsMode?: boolean;\n    /** provide statistics on job execution time. default: false */\n    verbose?: boolean;\n    readPreference?: string;\n    /** sets the output target for the map reduce job. default: {inline: 1} */\n    out?: {\n      /** the results are returned in an array */\n      inline?: number;\n      /**\n       * {replace: 'collectionName'} add the results to collectionName: the\n       * results replace the collection\n       */\n      replace?: string;\n      /**\n       * {reduce: 'collectionName'} add the results to collectionName: if\n       * dups are detected, uses the reducer / finalize functions\n       */\n      reduce?: string;\n      /**\n       * {merge: 'collectionName'} add the results to collectionName: if\n       * dups exist the new docs overwrite the old\n       */\n      merge?: string;\n    };\n  }\n\n  interface GeoSearchOptions {\n    /** x,y point to search for */\n    near: number[];\n    /** the maximum distance from the point near that a result can be */\n    maxDistance: number;\n    /** The maximum number of results to return */\n    limit?: number;\n    /** return the raw object instead of the Mongoose Model */\n    lean?: boolean;\n  }\n\n  interface PopulateOptions {\n    /** space delimited path(s) to populate */\n    path: string;\n    /** fields to select */\n    select?: any;\n    /** query conditions to match */\n    match?: any;\n    /** optional model to use for population */\n    model?: string | Model<any>;\n    /** optional query options like sort, limit, etc */\n    options?: any;\n    /** deep populate */\n    populate?: string | PopulateOptions | (string | PopulateOptions)[];\n    /**\n     * If true Mongoose will always set `path` to an array, if false Mongoose will\n     * always set `path` to a document. Inferred from schema by default.\n     */\n    justOne?: boolean;\n    /** transform function to call on every populated doc */\n    transform?: (doc: any, id: any) => any;\n  }\n\n  interface ToObjectOptions {\n    /** apply all getters (path and virtual getters) */\n    getters?: boolean;\n    /** apply virtual getters (can override getters option) */\n    virtuals?: boolean | string[];\n    /** if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`. */\n    aliases?: boolean;\n    /** remove empty objects (defaults to true) */\n    minimize?: boolean;\n    /** if set, mongoose will call this function to allow you to transform the returned object */\n    transform?: boolean | ((doc: any, ret: any, options: any) => any);\n    /** if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths. */\n    depopulate?: boolean;\n    /** if false, exclude the version key (`__v` by default) from the output */\n    versionKey?: boolean;\n    /** if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`. */\n    flattenMaps?: boolean;\n    /** If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema. */\n    useProjection?: boolean;\n  }\n\n  type MongooseDocumentMiddleware = 'validate' | 'save' | 'remove' | 'updateOne' | 'deleteOne' | 'init';\n  type MongooseQueryMiddleware = 'count' | 'deleteMany' | 'deleteOne' | 'distinct' | 'find' | 'findOne' | 'findOneAndDelete' | 'findOneAndRemove' | 'findOneAndUpdate' | 'remove' | 'update' | 'updateOne' | 'updateMany';\n\n  type SchemaPreOptions = { document?: boolean, query?: boolean };\n  type SchemaPostOptions = { document?: boolean, query?: boolean };\n\n  type ExtractVirtuals<M> = M extends Model<any, any, any, infer TVirtuals> ? TVirtuals : {};\n\n  type IndexDirection = 1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text';\n  type IndexDefinition = Record<string, IndexDirection>;\n\n  type PreMiddlewareFunction<T> = (this: T, next: (err?: CallbackError) => void) => void | Promise<void>;\n  type PreSaveMiddlewareFunction<T> = (this: T, next: (err?: CallbackError) => void, opts: SaveOptions) => void | Promise<void>;\n  type PostMiddlewareFunction<ThisType, ResType = any> = (this: ThisType, res: ResType, next: (err?: CallbackError) => void) => void | Promise<void>;\n  type ErrorHandlingMiddlewareFunction<ThisType, ResType = any> = (this: ThisType, err: NativeError, res: ResType, next: (err?: CallbackError) => void) => void;\n\n  class Schema<DocType = any, M = Model<DocType, any, any, any>, TInstanceMethods = any, TQueryHelpers = any> extends events.EventEmitter {\n    /**\n     * Create a new schema\n     */\n    constructor(definition?: SchemaDefinition<SchemaDefinitionType<DocType>>, options?: SchemaOptions);\n\n    /** Adds key path / schema type pairs to this schema. */\n    add(obj: SchemaDefinition<SchemaDefinitionType<DocType>> | Schema, prefix?: string): this;\n\n    /**\n     * Array of child schemas (from document arrays and single nested subdocs)\n     * and their corresponding compiled models. Each element of the array is\n     * an object with 2 properties: `schema` and `model`.\n     */\n    childSchemas: { schema: Schema, model: any }[];\n\n    /** Returns a copy of this schema */\n    clone<T = this>(): T;\n\n    /** Object containing discriminators defined on this schema */\n    discriminators?: { [name: string]: Schema };\n\n    /** Iterates the schemas paths similar to Array#forEach. */\n    eachPath(fn: (path: string, type: SchemaType) => void): this;\n\n    /** Defines an index (most likely compound) for this schema. */\n    index(fields: IndexDefinition, options?: IndexOptions): this;\n\n    /**\n     * Returns a list of indexes that this schema declares, via `schema.index()`\n     * or by `index: true` in a path's options.\n     */\n    indexes(): Array<IndexDefinition>;\n\n    /** Gets a schema option. */\n    get<K extends keyof SchemaOptions>(key: K): SchemaOptions[K];\n\n    /**\n     * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n     * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n     * to schema [virtuals](http://mongoosejs.com/docs/guide.html#virtuals),\n     * [statics](http://mongoosejs.com/docs/guide.html#statics), and\n     * [methods](http://mongoosejs.com/docs/guide.html#methods).\n     */\n    loadClass(model: Function, onlyVirtuals?: boolean): this;\n\n    /** Adds an instance method to documents constructed from Models compiled from this schema. */\n    method<Context = any>(name: string, fn: (this: Context, ...args: any[]) => any, opts?: any): this;\n    method(obj: Partial<TInstanceMethods>): this;\n\n    /** Object of currently defined methods on this schema. */\n    methods: { [F in keyof TInstanceMethods]: TInstanceMethods[F] };\n\n    /** The original object passed to the schema constructor */\n    obj: SchemaDefinition<SchemaDefinitionType<DocType>>;\n\n    /** Gets/sets schema paths. */\n    path<ResultType extends SchemaType = SchemaType>(path: string): ResultType;\n    path(path: string, constructor: any): this;\n\n    /** Lists all paths and their type in the schema. */\n    paths: {\n      [key: string]: SchemaType;\n    };\n\n    /** Returns the pathType of `path` for this schema. */\n    pathType(path: string): string;\n\n    /** Registers a plugin for this schema. */\n    plugin(fn: (schema: Schema<DocType>, opts?: any) => void, opts?: any): this;\n\n    /** Defines a post hook for the model. */\n    post<T = HydratedDocument<DocType, TInstanceMethods>>(method: MongooseDocumentMiddleware | MongooseDocumentMiddleware[] | RegExp, fn: PostMiddlewareFunction<T>): this;\n    post<T = HydratedDocument<DocType, TInstanceMethods>>(method: MongooseDocumentMiddleware | MongooseDocumentMiddleware[] | RegExp, options: SchemaPostOptions, fn: PostMiddlewareFunction<T>): this;\n    post<T extends Query<any, any>>(method: MongooseQueryMiddleware | MongooseQueryMiddleware[] | string | RegExp, fn: PostMiddlewareFunction<T>): this;\n    post<T extends Query<any, any>>(method: MongooseQueryMiddleware | MongooseQueryMiddleware[] | string | RegExp, options: SchemaPostOptions, fn: PostMiddlewareFunction<T>): this;\n    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, fn: PostMiddlewareFunction<T, Array<any>>): this;\n    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, options: SchemaPostOptions, fn: PostMiddlewareFunction<T, Array<any>>): this;\n    post<T = M>(method: 'insertMany' | RegExp, fn: PostMiddlewareFunction<T>): this;\n    post<T = M>(method: 'insertMany' | RegExp, options: SchemaPostOptions, fn: PostMiddlewareFunction<T>): this;\n\n    post<T = HydratedDocument<DocType, TInstanceMethods>>(method: MongooseDocumentMiddleware | MongooseDocumentMiddleware[] | RegExp, fn: ErrorHandlingMiddlewareFunction<T>): this;\n    post<T = HydratedDocument<DocType, TInstanceMethods>>(method: MongooseDocumentMiddleware | MongooseDocumentMiddleware[] | RegExp, options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;\n    post<T extends Query<any, any>>(method: MongooseQueryMiddleware | MongooseQueryMiddleware[] | string | RegExp, fn: ErrorHandlingMiddlewareFunction<T>): this;\n    post<T extends Query<any, any>>(method: MongooseQueryMiddleware | MongooseQueryMiddleware[] | string | RegExp, options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;\n    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, fn: ErrorHandlingMiddlewareFunction<T, Array<any>>): this;\n    post<T extends Aggregate<any>>(method: 'aggregate' | RegExp, options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T, Array<any>>): this;\n    post<T = M>(method: 'insertMany' | RegExp, fn: ErrorHandlingMiddlewareFunction<T>): this;\n    post<T = M>(method: 'insertMany' | RegExp, options: SchemaPostOptions, fn: ErrorHandlingMiddlewareFunction<T>): this;\n\n    /** Defines a pre hook for the model. */\n    pre<T = HydratedDocument<DocType, TInstanceMethods>>(method: 'save', fn: PreSaveMiddlewareFunction<T>): this;\n    pre<T = HydratedDocument<DocType, TInstanceMethods>>(method: MongooseDocumentMiddleware | MongooseDocumentMiddleware[] | RegExp, fn: PreMiddlewareFunction<T>): this;\n    pre<T extends Query<any, any>>(method: MongooseDocumentMiddleware | MongooseDocumentMiddleware[] | RegExp, options: SchemaPreOptions, fn: PreMiddlewareFunction<T>): this;\n    pre<T extends Query<any, any>>(method: MongooseQueryMiddleware | MongooseQueryMiddleware[] | string | RegExp, fn: PreMiddlewareFunction<T>): this;\n    pre<T extends Query<any, any>>(method: MongooseQueryMiddleware | MongooseQueryMiddleware[] | string | RegExp, options: SchemaPreOptions, fn: PreMiddlewareFunction<T>): this;\n    pre<T extends Aggregate<any>>(method: 'aggregate' | RegExp, fn: PreMiddlewareFunction<T>): this;\n    pre<T extends Aggregate<any>>(method: 'aggregate' | RegExp, options: SchemaPreOptions, fn: PreMiddlewareFunction<T>): this;\n    pre<T = M>(method: 'insertMany' | RegExp, fn: (this: T, next: (err?: CallbackError) => void, docs: any | Array<any>) => void | Promise<void>): this;\n    pre<T = M>(method: 'insertMany' | RegExp, options: SchemaPreOptions, fn: (this: T, next: (err?: CallbackError) => void, docs: any | Array<any>) => void | Promise<void>): this;\n\n    /** Object of currently defined query helpers on this schema. */\n    query: TQueryHelpers;\n\n    /** Adds a method call to the queue. */\n    queue(name: string, args: any[]): this;\n\n    /** Removes the given `path` (or [`paths`]). */\n    remove(paths: string | Array<string>): this;\n\n    /** Returns an Array of path strings that are required by this schema. */\n    requiredPaths(invalidate?: boolean): string[];\n\n    /** Sets a schema option. */\n    set<K extends keyof SchemaOptions>(key: K, value: SchemaOptions[K], _tags?: any): this;\n\n    /** Adds static \"class\" methods to Models compiled from this schema. */\n    static(name: string, fn: (this: M, ...args: any[]) => any): this;\n    static(obj: { [name: string]: (this: M, ...args: any[]) => any }): this;\n\n    /** Object of currently defined statics on this schema. */\n    statics: { [name: string]: (this: M, ...args: any[]) => any };\n\n    /** Creates a virtual type with the given name. */\n    virtual(name: string, options?: VirtualTypeOptions): VirtualType;\n\n    /** Object of currently defined virtuals on this schema */\n    virtuals: any;\n\n    /** Returns the virtual type with the given `name`. */\n    virtualpath(name: string): VirtualType | null;\n  }\n\n  type NumberSchemaDefinition = typeof Number | 'number' | 'Number' | typeof Schema.Types.Number;\n  type StringSchemaDefinition = typeof String | 'string' | 'String' | typeof Schema.Types.String;\n  type BooleanSchemaDefinition = typeof Boolean | 'boolean' | 'Boolean' | typeof Schema.Types.Boolean;\n  type DateSchemaDefinition = typeof NativeDate | 'date' | 'Date' | typeof Schema.Types.Date;\n\n  type SchemaDefinitionWithBuiltInClass<T> = T extends number\n    ? NumberSchemaDefinition\n    : T extends string\n    ? StringSchemaDefinition\n    : T extends boolean\n    ? BooleanSchemaDefinition\n    : T extends NativeDate\n    ? DateSchemaDefinition\n    : (Function | string);\n\n  type SchemaDefinitionProperty<T = undefined> = SchemaDefinitionWithBuiltInClass<T> |\n    SchemaTypeOptions<T extends undefined ? any : T> |\n    typeof SchemaType |\n    Schema<any, any, any> |\n    Schema<any, any, any>[] |\n    SchemaTypeOptions<T extends undefined ? any : T>[] |\n    Function[] |\n    SchemaDefinition<T> |\n    SchemaDefinition<T>[] |\n    typeof SchemaTypes.Mixed;\n\n  type SchemaDefinition<T = undefined> = T extends undefined\n    ? { [path: string]: SchemaDefinitionProperty; }\n    : { [path in keyof T]?: SchemaDefinitionProperty<T[path]>; };\n\n  interface SchemaOptions {\n    /**\n     * By default, Mongoose's init() function creates all the indexes defined in your model's schema by\n     * calling Model.createIndexes() after you successfully connect to MongoDB. If you want to disable\n     * automatic index builds, you can set autoIndex to false.\n     */\n    autoIndex?: boolean;\n    /**\n     * If set to `true`, Mongoose will call Model.createCollection() to create the underlying collection\n     * in MongoDB if autoCreate is set to true. Calling createCollection() sets the collection's default\n     * collation based on the collation option and establishes the collection as a capped collection if\n     * you set the capped schema option.\n     */\n    autoCreate?: boolean;\n    /**\n     * By default, mongoose buffers commands when the connection goes down until the driver manages to reconnect.\n     * To disable buffering, set bufferCommands to false.\n     */\n    bufferCommands?: boolean;\n    /**\n     * If bufferCommands is on, this option sets the maximum amount of time Mongoose buffering will wait before\n     * throwing an error. If not specified, Mongoose will use 10000 (10 seconds).\n     */\n    bufferTimeoutMS?: number;\n    /**\n     * Mongoose supports MongoDBs capped collections. To specify the underlying MongoDB collection be capped, set\n     * the capped option to the maximum size of the collection in bytes.\n     */\n    capped?: boolean | number | { size?: number; max?: number; autoIndexId?: boolean; };\n    /** Sets a default collation for every query and aggregation. */\n    collation?: mongodb.CollationOptions;\n\n    /** The timeseries option to use when creating the model's collection. */\n    timeseries?: mongodb.TimeSeriesCollectionOptions;\n\n    /**\n     * Mongoose by default produces a collection name by passing the model name to the utils.toCollectionName\n     * method. This method pluralizes the name. Set this option if you need a different name for your collection.\n     */\n    collection?: string;\n    /**\n     * When you define a [discriminator](/docs/discriminators.html), Mongoose adds a path to your\n     * schema that stores which discriminator a document is an instance of. By default, Mongoose\n     * adds an `__t` path, but you can set `discriminatorKey` to overwrite this default.\n     */\n    discriminatorKey?: string;\n    /** defaults to false. */\n    emitIndexErrors?: boolean;\n    excludeIndexes?: any;\n    /**\n     * Mongoose assigns each of your schemas an id virtual getter by default which returns the document's _id field\n     * cast to a string, or in the case of ObjectIds, its hexString.\n     */\n    id?: boolean;\n    /**\n     * Mongoose assigns each of your schemas an _id field by default if one is not passed into the Schema\n     * constructor. The type assigned is an ObjectId to coincide with MongoDB's default behavior. If you\n     * don't want an _id added to your schema at all, you may disable it using this option.\n     */\n    _id?: boolean;\n    /**\n     * Mongoose will, by default, \"minimize\" schemas by removing empty objects. This behavior can be\n     * overridden by setting minimize option to false. It will then store empty objects.\n     */\n    minimize?: boolean;\n    /**\n     * Optimistic concurrency is a strategy to ensure the document you're updating didn't change between when you\n     * loaded it using find() or findOne(), and when you update it using save(). Set to `true` to enable\n     * optimistic concurrency.\n     */\n    optimisticConcurrency?: boolean;\n    /**\n     * Allows setting query#read options at the schema level, providing us a way to apply default ReadPreferences\n     * to all queries derived from a model.\n     */\n    read?: string;\n    /** Allows setting write concern at the schema level. */\n    writeConcern?: WriteConcern;\n    /** defaults to true. */\n    safe?: boolean | { w?: number | string; wtimeout?: number; j?: boolean };\n    /**\n     * The shardKey option is used when we have a sharded MongoDB architecture. Each sharded collection is\n     * given a shard key which must be present in all insert/update operations. We just need to set this\n     * schema option to the same shard key and we'll be all set.\n     */\n    shardKey?: Record<string, unknown>;\n    /**\n     * The strict option, (enabled by default), ensures that values passed to our model constructor that were not\n     * specified in our schema do not get saved to the db.\n     */\n    strict?: boolean | 'throw';\n    /**\n     * equal to `strict` by default, may be `false`, `true`, or `'throw'`. Sets the default\n     * [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery) mode for schemas.\n     */\n    strictQuery?: boolean | 'throw';\n    /** Exactly the same as the toObject option but only applies when the document's toJSON method is called. */\n    toJSON?: ToObjectOptions;\n    /**\n     * Documents have a toObject method which converts the mongoose document into a plain JavaScript object.\n     * This method accepts a few options. Instead of applying these options on a per-document basis, we may\n     * declare the options at the schema level and have them applied to all of the schema's documents by\n     * default.\n     */\n    toObject?: ToObjectOptions;\n    /**\n     * By default, if you have an object with key 'type' in your schema, mongoose will interpret it as a\n     * type declaration. However, for applications like geoJSON, the 'type' property is important. If you want to\n     * control which key mongoose uses to find type declarations, set the 'typeKey' schema option.\n     */\n    typeKey?: string;\n\n    /**\n     * By default, documents are automatically validated before they are saved to the database. This is to\n     * prevent saving an invalid document. If you want to handle validation manually, and be able to save\n     * objects which don't pass validation, you can set validateBeforeSave to false.\n     */\n    validateBeforeSave?: boolean;\n    /**\n     * The versionKey is a property set on each document when first created by Mongoose. This keys value\n     * contains the internal revision of the document. The versionKey option is a string that represents\n     * the path to use for versioning. The default is '__v'.\n     */\n    versionKey?: string | boolean;\n    /**\n     * By default, Mongoose will automatically select() any populated paths for you, unless you explicitly exclude them.\n     */\n    selectPopulatedPaths?: boolean;\n    /**\n     * skipVersioning allows excluding paths from versioning (i.e., the internal revision will not be\n     * incremented even if these paths are updated). DO NOT do this unless you know what you're doing.\n     * For subdocuments, include this on the parent document using the fully qualified path.\n     */\n    skipVersioning?: any;\n    /**\n     * Validation errors in a single nested schema are reported\n     * both on the child and on the parent schema.\n     * Set storeSubdocValidationError to false on the child schema\n     * to make Mongoose only report the parent error.\n     */\n    storeSubdocValidationError?: boolean;\n    /**\n     * The timestamps option tells mongoose to assign createdAt and updatedAt fields to your schema. The type\n     * assigned is Date. By default, the names of the fields are createdAt and updatedAt. Customize the\n     * field names by setting timestamps.createdAt and timestamps.updatedAt.\n     */\n    timestamps?: boolean | SchemaTimestampsConfig;\n  }\n\n  interface SchemaTimestampsConfig {\n    createdAt?: boolean | string;\n    updatedAt?: boolean | string;\n    currentTime?: () => (NativeDate | number);\n  }\n\n  type Unpacked<T> = T extends (infer U)[] ?\n    U :\n    T extends ReadonlyArray<infer U> ? U : T;\n\n  type AnyArray<T> = T[] | ReadonlyArray<T>;\n\n  export class SchemaTypeOptions<T> {\n    type?:\n      T extends string ? StringSchemaDefinition :\n      T extends number ? NumberSchemaDefinition :\n      T extends boolean ? BooleanSchemaDefinition :\n      T extends NativeDate ? DateSchemaDefinition :\n      T extends Map<any, any> ? SchemaDefinition<typeof Map> :\n      T extends Buffer ? SchemaDefinition<typeof Buffer> :\n      T extends object[] ? (AnyArray<Schema<any, any, any>> | AnyArray<SchemaDefinition<Unpacked<T>>> | AnyArray<SchemaTypeOptions<Unpacked<T>>>) :\n      T extends string[] ? AnyArray<StringSchemaDefinition> | AnyArray<SchemaTypeOptions<string>> :\n      T extends number[] ? AnyArray<NumberSchemaDefinition> | AnyArray<SchemaTypeOptions<number>> :\n      T extends boolean[] ? AnyArray<BooleanSchemaDefinition> | AnyArray<SchemaTypeOptions<boolean>> :\n      T extends Function[] ? AnyArray<Function | string> | AnyArray<SchemaTypeOptions<Unpacked<T>>> :\n      T | typeof SchemaType | Schema<any, any, any> | SchemaDefinition<T> | Function | AnyArray<Function>;\n\n    /** Defines a virtual with the given name that gets/sets this path. */\n    alias?: string;\n\n    /** Function or object describing how to validate this schematype. See [validation docs](https://mongoosejs.com/docs/validation.html). */\n    validate?: RegExp | [RegExp, string] | Function | [Function, string] | ValidateOpts<T> | ValidateOpts<T>[];\n\n    /** Allows overriding casting logic for this individual path. If a string, the given string overwrites Mongoose's default cast error message. */\n    cast?: string;\n\n    /**\n     * If true, attach a required validator to this path, which ensures this path\n     * path cannot be set to a nullish value. If a function, Mongoose calls the\n     * function and only checks for nullish values if the function returns a truthy value.\n     */\n    required?: boolean | (() => boolean) | [boolean, string] | [() => boolean, string];\n\n    /**\n     * The default value for this path. If a function, Mongoose executes the function\n     * and uses the return value as the default.\n     */\n    default?: T | ((this: any, doc: any) => Partial<T>);\n\n    /**\n     * The model that `populate()` should use if populating this path.\n     */\n    ref?: string | Model<any> | ((this: any, doc: any) => string | Model<any>);\n\n    /**\n     * Whether to include or exclude this path by default when loading documents\n     * using `find()`, `findOne()`, etc.\n     */\n    select?: boolean | number;\n\n    /**\n     * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n     * build an index on this path when the model is compiled.\n     */\n    index?: boolean | number | IndexOptions | '2d' | '2dsphere' | 'hashed' | 'text';\n\n    /**\n     * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\n     * will build a unique index on this path when the\n     * model is compiled. [The `unique` option is **not** a validator](/docs/validation.html#the-unique-option-is-not-a-validator).\n     */\n    unique?: boolean | number;\n\n    /**\n     * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n     * disallow changes to this path once the document is saved to the database for the first time. Read more\n     * about [immutability in Mongoose here](http://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).\n     */\n    immutable?: boolean | ((this: any, doc: any) => boolean);\n\n    /**\n     * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n     * build a sparse index on this path.\n     */\n    sparse?: boolean | number;\n\n    /**\n     * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\n     * will build a text index on this path.\n     */\n    text?: boolean | number | any;\n\n    /**\n     * Define a transform function for this individual schema type.\n     * Only called when calling `toJSON()` or `toObject()`.\n     */\n    transform?: (this: any, val: T) => any;\n\n    /** defines a custom getter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty). */\n    get?: (value: T, doc?: this) => any;\n\n    /** defines a custom setter for this property using [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty). */\n    set?: (value: any, priorVal?: T, doc?: this) => any;\n\n    /** array of allowed values for this path. Allowed for strings, numbers, and arrays of strings */\n    enum?: Array<string | number | null> | ReadonlyArray<string | number | null> | { values: Array<string | number | null> | ReadonlyArray<string | number | null>, message?: string } | { [path: string]: string | number | null };\n\n    /** The default [subtype](http://bsonspec.org/spec.html) associated with this buffer when it is stored in MongoDB. Only allowed for buffer paths */\n    subtype?: number;\n\n    /** The minimum value allowed for this path. Only allowed for numbers and dates. */\n    min?: number | NativeDate | [number, string] | [NativeDate, string] | readonly [number, string] | readonly [NativeDate, string];\n\n    /** The maximum value allowed for this path. Only allowed for numbers and dates. */\n    max?: number | NativeDate | [number, string] | [NativeDate, string] | readonly [number, string] | readonly [NativeDate, string];\n\n    /** Defines a TTL index on this path. Only allowed for dates. */\n    expires?: string | number;\n\n    /** If `true`, Mongoose will skip gathering indexes on subpaths. Only allowed for subdocuments and subdocument arrays. */\n    excludeIndexes?: boolean;\n\n    /** If set, overrides the child schema's `_id` option. Only allowed for subdocuments and subdocument arrays. */\n    _id?: boolean;\n\n    /** If set, specifies the type of this map's values. Mongoose will cast this map's values to the given type. */\n    of?: Function | SchemaDefinitionProperty<any>;\n\n    /** If true, uses Mongoose's default `_id` settings. Only allowed for ObjectIds */\n    auto?: boolean;\n\n    /** Attaches a validator that succeeds if the data string matches the given regular expression, and fails otherwise. */\n    match?: RegExp | [RegExp, string] | readonly [RegExp, string];\n\n    /** If truthy, Mongoose will add a custom setter that lowercases this string using JavaScript's built-in `String#toLowerCase()`. */\n    lowercase?: boolean;\n\n    /** If truthy, Mongoose will add a custom setter that removes leading and trailing whitespace using JavaScript's built-in `String#trim()`. */\n    trim?: boolean;\n\n    /** If truthy, Mongoose will add a custom setter that uppercases this string using JavaScript's built-in `String#toUpperCase()`. */\n    uppercase?: boolean;\n\n    /** If set, Mongoose will add a custom validator that ensures the given string's `length` is at least the given number. */\n    minlength?: number | [number, string] | readonly [number, string];\n\n    /** If set, Mongoose will add a custom validator that ensures the given string's `length` is at most the given number. */\n    maxlength?: number | [number, string] | readonly [number, string];\n\n    [other: string]: any;\n  }\n\n  export type RefType =\n    | number\n    | string\n    | Buffer\n    | undefined\n    | mongoose.Types.ObjectId\n    | mongoose.Types.Buffer\n    | typeof mongoose.Schema.Types.Number\n    | typeof mongoose.Schema.Types.String\n    | typeof mongoose.Schema.Types.Buffer\n    | typeof mongoose.Schema.Types.ObjectId;\n\n  /**\n   * Reference another Model\n   */\n  export type PopulatedDoc<\n    PopulatedType,\n    RawId extends RefType = (PopulatedType extends { _id?: RefType; } ? NonNullable<PopulatedType['_id']> : mongoose.Types.ObjectId) | undefined\n    > = PopulatedType | RawId;\n\n  interface IndexOptions extends mongodb.CreateIndexesOptions {\n    /**\n     * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n     *\n     * @example\n     * ```js\n     * const schema = new Schema({ prop1: Date });\n     *\n     * // expire in 24 hours\n     * schema.index({ prop1: 1 }, { expires: 60*60*24 })\n     *\n     * // expire in 24 hours\n     * schema.index({ prop1: 1 }, { expires: '24h' })\n     *\n     * // expire in 1.5 hours\n     * schema.index({ prop1: 1 }, { expires: '1.5h' })\n     *\n     * // expire in 7 days\n     * schema.index({ prop1: 1 }, { expires: '7d' })\n     * ```\n     */\n    expires?: number | string;\n    weights?: AnyObject;\n  }\n\n  interface ValidatorProps {\n    path: string;\n    value: any;\n  }\n\n  interface ValidatorMessageFn {\n    (props: ValidatorProps): string;\n  }\n\n  interface ValidateFn<T> {\n    (value: T): boolean;\n  }\n\n  interface LegacyAsyncValidateFn<T> {\n    (value: T, done: (result: boolean) => void): void;\n  }\n\n  interface AsyncValidateFn<T> {\n    (value: any): Promise<boolean>;\n  }\n\n  interface ValidateOpts<T> {\n    msg?: string;\n    message?: string | ValidatorMessageFn;\n    type?: string;\n    validator: ValidateFn<T> | LegacyAsyncValidateFn<T> | AsyncValidateFn<T>;\n  }\n\n  interface VirtualTypeOptions {\n    /** If `ref` is not nullish, this becomes a populated virtual. */\n    ref?: string | Function;\n\n    /**  The local field to populate on if this is a populated virtual. */\n    localField?: string | Function;\n\n    /** The foreign field to populate on if this is a populated virtual. */\n    foreignField?: string | Function;\n\n    /**\n     * By default, a populated virtual is an array. If you set `justOne`,\n     * the populated virtual will be a single doc or `null`.\n     */\n    justOne?: boolean;\n\n    /** If you set this to `true`, Mongoose will call any custom getters you defined on this virtual. */\n    getters?: boolean;\n\n    /**\n     * If you set this to `true`, `populate()` will set this virtual to the number of populated\n     * documents, as opposed to the documents themselves, using `Query#countDocuments()`.\n     */\n    count?: boolean;\n\n    /** Add an extra match condition to `populate()`. */\n    match?: FilterQuery<any> | Function;\n\n    /** Add a default `limit` to the `populate()` query. */\n    limit?: number;\n\n    /** Add a default `skip` to the `populate()` query. */\n    skip?: number;\n\n    /**\n     * For legacy reasons, `limit` with `populate()` may give incorrect results because it only\n     * executes a single query for every document being populated. If you set `perDocumentLimit`,\n     * Mongoose will ensure correct `limit` per document by executing a separate query for each\n     * document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })`\n     * will execute 2 additional queries if `.find()` returns 2 documents.\n     */\n    perDocumentLimit?: number;\n\n    /** Additional options like `limit` and `lean`. */\n    options?: QueryOptions & { match?: AnyObject };\n\n    /** Additional options for plugins */\n    [extra: string]: any;\n  }\n\n  class VirtualType {\n    /** Applies getters to `value`. */\n    applyGetters(value: any, doc: Document): any;\n\n    /** Applies setters to `value`. */\n    applySetters(value: any, doc: Document): any;\n\n    /** Adds a custom getter to this virtual. */\n    get(fn: Function): this;\n\n    /** Adds a custom setter to this virtual. */\n    set(fn: Function): this;\n  }\n\n  namespace Schema {\n    namespace Types {\n      class Array extends SchemaType implements AcceptsDiscriminator {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n\n        static options: { castNonArrays: boolean; };\n\n        discriminator<D>(name: string | number, schema: Schema, value?: string): Model<D>;\n        discriminator<T, U>(name: string | number, schema: Schema<T, U>, value?: string): U;\n\n        /** The schematype embedded in this array */\n        caster?: SchemaType;\n\n        /**\n         * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n         * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n         */\n        enum(vals: string[] | number[]): this;\n      }\n\n      class Boolean extends SchemaType {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n\n        /** Configure which values get casted to `true`. */\n        static convertToTrue: Set<any>;\n\n        /** Configure which values get casted to `false`. */\n        static convertToFalse: Set<any>;\n      }\n\n      class Buffer extends SchemaType {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n\n        /**\n         * Sets the default [subtype](https://studio3t.com/whats-new/best-practices-uuid-mongodb/)\n         * for this buffer. You can find a [list of allowed subtypes here](http://api.mongodb.com/python/current/api/bson/binary.html).\n         */\n        subtype(subtype: number): this;\n      }\n\n      class Date extends SchemaType {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n\n        /** Declares a TTL index (rounded to the nearest second) for _Date_ types only. */\n        expires(when: number | string): this;\n\n        /** Sets a maximum date validator. */\n        max(value: NativeDate, message: string): this;\n\n        /** Sets a minimum date validator. */\n        min(value: NativeDate, message: string): this;\n      }\n\n      class Decimal128 extends SchemaType {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n      }\n\n      class DocumentArray extends SchemaType implements AcceptsDiscriminator {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n\n        static options: { castNonArrays: boolean; };\n\n        discriminator<D>(name: string | number, schema: Schema, value?: string): Model<D>;\n        discriminator<T, U>(name: string | number, schema: Schema<T, U>, value?: string): U;\n\n        /** The schema used for documents in this array */\n        schema: Schema;\n\n        /** The constructor used for subdocuments in this array */\n        caster?: typeof Types.Subdocument;\n      }\n\n      class Map extends SchemaType {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n      }\n\n      class Mixed extends SchemaType {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n      }\n\n      class Number extends SchemaType {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n\n        /** Sets a enum validator */\n        enum(vals: number[]): this;\n\n        /** Sets a maximum number validator. */\n        max(value: number, message: string): this;\n\n        /** Sets a minimum number validator. */\n        min(value: number, message: string): this;\n      }\n\n      class ObjectId extends SchemaType {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n\n        /** Adds an auto-generated ObjectId default if turnOn is true. */\n        auto(turnOn: boolean): this;\n      }\n\n      class Subdocument extends SchemaType implements AcceptsDiscriminator {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n\n        /** The document's schema */\n        schema: Schema;\n\n        discriminator<D>(name: string | number, schema: Schema, value?: string): Model<D>;\n        discriminator<T, U>(name: string | number, schema: Schema<T, U>, value?: string): U;\n      }\n\n      class String extends SchemaType {\n        /** This schema type's name, to defend against minifiers that mangle function names. */\n        static schemaName: string;\n\n        /** Adds an enum validator */\n        enum(vals: string[] | any): this;\n\n        /** Adds a lowercase [setter](http://mongoosejs.com/docs/api.html#schematype_SchemaType-set). */\n        lowercase(shouldApply?: boolean): this;\n\n        /** Sets a regexp validator. */\n        match(value: RegExp, message: string): this;\n\n        /** Sets a maximum length validator. */\n        maxlength(value: number, message: string): this;\n\n        /** Sets a minimum length validator. */\n        minlength(value: number, message: string): this;\n\n        /** Adds a trim [setter](http://mongoosejs.com/docs/api.html#schematype_SchemaType-set). */\n        trim(shouldTrim?: boolean): this;\n\n        /** Adds an uppercase [setter](http://mongoosejs.com/docs/api.html#schematype_SchemaType-set). */\n        uppercase(shouldApply?: boolean): this;\n      }\n    }\n  }\n\n  namespace Types {\n    class Array<T> extends global.Array<T> {\n      /** Pops the array atomically at most one time per document `save()`. */\n      $pop(): T;\n\n      /** Atomically shifts the array at most one time per document `save()`. */\n      $shift(): T;\n\n      /** Adds values to the array if not already present. */\n      addToSet(...args: any[]): any[];\n\n      isMongooseArray: true;\n\n      /** Pushes items to the array non-atomically. */\n      nonAtomicPush(...args: any[]): number;\n\n      /** Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking. */\n      push(...args: any[]): number;\n\n      /**\n       * Pulls items from the array atomically. Equality is determined by casting\n       * the provided value to an embedded document and comparing using\n       * [the `Document.equals()` function.](./api.html#document_Document-equals)\n       */\n      pull(...args: any[]): this;\n\n      /**\n       * Alias of [pull](#mongoosearray_MongooseArray-pull)\n       */\n      remove(...args: any[]): this;\n\n      /** Sets the casted `val` at index `i` and marks the array modified. */\n      set(i: number, val: T): this;\n\n      /** Atomically shifts the array at most one time per document `save()`. */\n      shift(): T;\n\n      /** Returns a native js Array. */\n      toObject(options?: ToObjectOptions): any;\n      toObject<T>(options?: ToObjectOptions): T;\n\n      /** Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking. */\n      unshift(...args: any[]): number;\n    }\n\n    class Buffer extends global.Buffer {\n      /** Sets the subtype option and marks the buffer modified. */\n      subtype(subtype: number | ToObjectOptions): void;\n\n      /** Converts this buffer to its Binary type representation. */\n      toObject(subtype?: number): mongodb.Binary;\n    }\n\n    class Decimal128 extends mongodb.Decimal128 { }\n\n    class DocumentArray<T> extends Types.Array<T> {\n      /** DocumentArray constructor */\n      constructor(values: any[]);\n\n      isMongooseDocumentArray: true;\n\n      /** Creates a subdocument casted to this schema. */\n      create(obj: any): T;\n\n      /** Searches array items for the first document with a matching _id. */\n      id(id: any): T | null;\n\n      push(...args: (AnyKeys<T> & AnyObject)[]): number;\n    }\n\n    class Map<V> extends global.Map<string, V> {\n      /** Converts a Mongoose map into a vanilla JavaScript map. */\n      toObject(options?: ToObjectOptions & { flattenMaps?: boolean }): any;\n    }\n\n    class ObjectId extends mongodb.ObjectId {\n      _id: this;\n    }\n\n    class Subdocument<IdType = any> extends Document<IdType> {\n      $isSingleNested: true;\n\n      /** Returns the top level document of this sub-document. */\n      ownerDocument(): Document;\n\n      /** Returns this sub-documents parent document. */\n      parent(): Document;\n\n      /** Returns this sub-documents parent document. */\n      $parent(): Document;\n    }\n\n    class ArraySubdocument<IdType = any> extends Subdocument<IdType> {\n      /** Returns this sub-documents parent array. */\n      parentArray(): Types.DocumentArray<unknown>;\n    }\n  }\n\n  type ReturnsNewDoc = { new: true } | { returnOriginal: false } | {returnDocument: 'after'};\n\n  type QueryWithHelpers<ResultType, DocType, THelpers = {}, RawDocType = DocType> = Query<ResultType, DocType, THelpers, RawDocType> & THelpers;\n\n  type UnpackedIntersection<T, U> = T extends (infer V)[] ? (V & U)[] : T & U;\n\n  class Query<ResultType, DocType, THelpers = {}, RawDocType = DocType> {\n    _mongooseOptions: MongooseQueryOptions;\n\n    /**\n     * Returns a wrapper around a [mongodb driver cursor](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html).\n     * A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.\n     * This is equivalent to calling `.cursor()` with no arguments.\n     */\n    [Symbol.asyncIterator](): AsyncIterableIterator<DocType>;\n\n    /** Executes the query */\n    exec(): Promise<ResultType>;\n    exec(callback?: Callback<ResultType>): void;\n    // @todo: this doesn't seem right\n    exec(callback?: Callback<ResultType>): Promise<ResultType> | any;\n\n    $where(argument: string | Function): QueryWithHelpers<DocType[], DocType, THelpers, RawDocType>;\n\n    /** Specifies an `$all` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    all(val: Array<any>): this;\n    all(path: string, val: Array<any>): this;\n\n    /** Sets the allowDiskUse option for the query (ignored for < 4.4.0) */\n    allowDiskUse(value: boolean): this;\n\n    /** Specifies arguments for an `$and` condition. */\n    and(array: FilterQuery<DocType>[]): this;\n\n    /** Specifies the batchSize option. */\n    batchSize(val: number): this;\n\n    /** Specifies a `$box` condition */\n    box(val: any): this;\n    box(lower: number[], upper: number[]): this;\n\n    /**\n     * Casts this query to the schema of `model`.\n     *\n     * @param {Model} [model] the model to cast to. If not set, defaults to `this.model`\n     * @param {Object} [obj] If not set, defaults to this query's conditions\n     * @return {Object} the casted `obj`\n     */\n    cast(model?: Model<any, THelpers> | null, obj?: any): any;\n\n    /**\n     * Executes the query returning a `Promise` which will be\n     * resolved with either the doc(s) or rejected with the error.\n     * Like `.then()`, but only takes a rejection handler.\n     */\n    catch: Promise<ResultType>['catch'];\n\n    /** Specifies a `$center` or `$centerSphere` condition. */\n    circle(area: any): this;\n    circle(path: string, area: any): this;\n\n    /** Make a copy of this query so you can re-execute it. */\n    clone(): this;\n\n    /** Adds a collation to this op (MongoDB 3.4 and up) */\n    collation(value: mongodb.CollationOptions): this;\n\n    /** Specifies the `comment` option. */\n    comment(val: string): this;\n\n    /** Specifies this query as a `count` query. */\n    count(callback?: Callback<number>): QueryWithHelpers<number, DocType, THelpers, RawDocType>;\n    count(criteria: FilterQuery<DocType>, callback?: Callback<number>): QueryWithHelpers<number, DocType, THelpers, RawDocType>;\n\n    /** Specifies this query as a `countDocuments` query. */\n    countDocuments(callback?: Callback<number>): QueryWithHelpers<number, DocType, THelpers, RawDocType>;\n    countDocuments(criteria: FilterQuery<DocType>, options?: QueryOptions, callback?: Callback<number>): QueryWithHelpers<number, DocType, THelpers, RawDocType>;\n\n    /**\n     * Returns a wrapper around a [mongodb driver cursor](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html).\n     * A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.\n     */\n    cursor(options?: any): QueryCursor<DocType>;\n\n    /**\n     * Declare and/or execute this query as a `deleteMany()` operation. Works like\n     * remove, except it deletes _every_ document that matches `filter` in the\n     * collection, regardless of the value of `single`.\n     */\n    deleteMany(filter?: FilterQuery<DocType>, options?: QueryOptions, callback?: Callback): QueryWithHelpers<any, DocType, THelpers, RawDocType>;\n    deleteMany(filter: FilterQuery<DocType>, callback: Callback): QueryWithHelpers<any, DocType, THelpers, RawDocType>;\n    deleteMany(callback: Callback): QueryWithHelpers<any, DocType, THelpers, RawDocType>;\n\n    /**\n     * Declare and/or execute this query as a `deleteOne()` operation. Works like\n     * remove, except it deletes at most one document regardless of the `single`\n     * option.\n     */\n    deleteOne(filter?: FilterQuery<DocType>, options?: QueryOptions, callback?: Callback): QueryWithHelpers<any, DocType, THelpers, RawDocType>;\n    deleteOne(filter: FilterQuery<DocType>, callback: Callback): QueryWithHelpers<any, DocType, THelpers, RawDocType>;\n    deleteOne(callback: Callback): QueryWithHelpers<any, DocType, THelpers, RawDocType>;\n\n    /** Creates a `distinct` query: returns the distinct values of the given `field` that match `filter`. */\n    distinct(field: string, filter?: FilterQuery<DocType>, callback?: Callback<number>): QueryWithHelpers<Array<any>, DocType, THelpers, RawDocType>;\n\n    /** Specifies a `$elemMatch` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    elemMatch(val: Function | any): this;\n    elemMatch(path: string, val: Function | any): this;\n\n    /**\n     * Gets/sets the error flag on this query. If this flag is not null or\n     * undefined, the `exec()` promise will reject without executing.\n     */\n    error(): NativeError | null;\n    error(val: NativeError | null): this;\n\n    /** Specifies the complementary comparison value for paths specified with `where()` */\n    equals(val: any): this;\n\n    /** Creates a `estimatedDocumentCount` query: counts the number of documents in the collection. */\n    estimatedDocumentCount(options?: QueryOptions, callback?: Callback<number>): QueryWithHelpers<number, DocType, THelpers, RawDocType>;\n\n    /** Specifies a `$exists` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    exists(val: boolean): this;\n    exists(path: string, val: boolean): this;\n\n    /**\n     * Sets the [`explain` option](https://docs.mongodb.com/manual/reference/method/cursor.explain/),\n     * which makes this query return detailed execution stats instead of the actual\n     * query result. This method is useful for determining what index your queries\n     * use.\n     */\n    explain(verbose?: string): this;\n\n    /** Creates a `find` query: gets a list of documents that match `filter`. */\n    find(callback?: Callback<DocType[]>): QueryWithHelpers<Array<DocType>, DocType, THelpers, RawDocType>;\n    find(filter: FilterQuery<DocType>, callback?: Callback<DocType[]>): QueryWithHelpers<Array<DocType>, DocType, THelpers, RawDocType>;\n    find(filter: FilterQuery<DocType>, projection?: any | null, options?: QueryOptions | null, callback?: Callback<DocType[]>): QueryWithHelpers<Array<DocType>, DocType, THelpers, RawDocType>;\n\n    /** Declares the query a findOne operation. When executed, the first found document is passed to the callback. */\n    findOne(filter?: FilterQuery<DocType>, projection?: any | null, options?: QueryOptions | null, callback?: Callback<DocType | null>): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType>;\n\n    /** Creates a `findOneAndDelete` query: atomically finds the given document, deletes it, and returns the document as it was before deletion. */\n    findOneAndDelete(filter?: FilterQuery<DocType>, options?: QueryOptions | null, callback?: (err: CallbackError, doc: DocType | null, res: any) => void): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType>;\n\n    /** Creates a `findOneAndRemove` query: atomically finds the given document and deletes it. */\n    findOneAndRemove(filter?: FilterQuery<DocType>, options?: QueryOptions | null, callback?: (err: CallbackError, doc: DocType | null, res: any) => void): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType>;\n\n    /** Creates a `findOneAndUpdate` query: atomically find the first document that matches `filter` and apply `update`. */\n    findOneAndUpdate(filter: FilterQuery<DocType>, update: UpdateQuery<DocType>, options: QueryOptions & { rawResult: true }, callback?: (err: CallbackError, doc: DocType | null, res: mongodb.ModifyResult<DocType>) => void): QueryWithHelpers<mongodb.ModifyResult<DocType>, DocType, THelpers, RawDocType>;\n    findOneAndUpdate(filter: FilterQuery<DocType>, update: UpdateQuery<DocType>, options: QueryOptions & { upsert: true } & ReturnsNewDoc, callback?: (err: CallbackError, doc: DocType, res: mongodb.ModifyResult<DocType>) => void): QueryWithHelpers<DocType, DocType, THelpers, RawDocType>;\n    findOneAndUpdate(filter?: FilterQuery<DocType>, update?: UpdateQuery<DocType>, options?: QueryOptions | null, callback?: (err: CallbackError, doc: DocType | null, res: mongodb.ModifyResult<DocType>) => void): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType>;\n\n    /** Creates a `findByIdAndDelete` query, filtering by the given `_id`. */\n    findByIdAndDelete(id?: mongodb.ObjectId | any, options?: QueryOptions | null, callback?: (err: CallbackError, doc: DocType | null, res: any) => void): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType>;\n\n    /** Creates a `findOneAndUpdate` query, filtering by the given `_id`. */\n    findByIdAndUpdate(id: mongodb.ObjectId | any, update: UpdateQuery<DocType>, options: QueryOptions & { rawResult: true }, callback?: (err: CallbackError, doc: any, res?: any) => void): QueryWithHelpers<any, DocType, THelpers, RawDocType>;\n    findByIdAndUpdate(id: mongodb.ObjectId | any, update: UpdateQuery<DocType>, options: QueryOptions & { upsert: true } & ReturnsNewDoc, callback?: (err: CallbackError, doc: DocType, res?: any) => void): QueryWithHelpers<DocType, DocType, THelpers, RawDocType>;\n    findByIdAndUpdate(id?: mongodb.ObjectId | any, update?: UpdateQuery<DocType>, options?: QueryOptions | null, callback?: (CallbackError: any, doc: DocType | null, res?: any) => void): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType>;\n    findByIdAndUpdate(id: mongodb.ObjectId | any, update: UpdateQuery<DocType>, callback: (CallbackError: any, doc: DocType | null, res?: any) => void): QueryWithHelpers<DocType | null, DocType, THelpers, RawDocType>;\n\n    /** Specifies a `$geometry` condition */\n    geometry(object: { type: string, coordinates: any[] }): this;\n\n    /**\n     * For update operations, returns the value of a path in the update's `$set`.\n     * Useful for writing getters/setters that can work with both update operations\n     * and `save()`.\n     */\n    get(path: string): any;\n\n    /** Returns the current query filter (also known as conditions) as a POJO. */\n    getFilter(): FilterQuery<DocType>;\n\n    /** Gets query options. */\n    getOptions(): QueryOptions;\n\n    /** Gets a list of paths to be populated by this query */\n    getPopulatedPaths(): Array<string>;\n\n    /** Returns the current query filter. Equivalent to `getFilter()`. */\n    getQuery(): FilterQuery<DocType>;\n\n    /** Returns the current update operations as a JSON object. */\n    getUpdate(): UpdateQuery<DocType> | UpdateWithAggregationPipeline | null;\n\n    /** Specifies a `$gt` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    gt(val: number): this;\n    gt(path: string, val: number): this;\n\n    /** Specifies a `$gte` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    gte(val: number): this;\n    gte(path: string, val: number): this;\n\n    /** Sets query hints. */\n    hint(val: any): this;\n\n    /** Specifies an `$in` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    in(val: Array<any>): this;\n    in(path: string, val: Array<any>): this;\n\n    /** Declares an intersects query for `geometry()`. */\n    intersects(arg?: any): this;\n\n    /** Requests acknowledgement that this operation has been persisted to MongoDB's on-disk journal. */\n    j(val: boolean | null): this;\n\n    /** Sets the lean option. */\n    lean<LeanResultType = RawDocType extends Document ? LeanDocumentOrArray<ResultType> : LeanDocumentOrArrayWithRawType<ResultType, Require_id<RawDocType>>>(val?: boolean | any): QueryWithHelpers<LeanResultType, DocType, THelpers, RawDocType>;\n\n    /** Specifies the maximum number of documents the query will return. */\n    limit(val: number): this;\n\n    /** Specifies a `$lt` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    lt(val: number): this;\n    lt(path: string, val: number): this;\n\n    /** Specifies a `$lte` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    lte(val: number): this;\n    lte(path: string, val: number): this;\n\n    /**\n     * Runs a function `fn` and treats the return value of `fn` as the new value\n     * for the query to resolve to.\n     */\n    transform<MappedType>(fn: (doc: ResultType) => MappedType): QueryWithHelpers<MappedType, DocType, THelpers, RawDocType>;\n\n    /** Specifies an `$maxDistance` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    maxDistance(val: number): this;\n    maxDistance(path: string, val: number): this;\n\n    /** Specifies the maxScan option. */\n    maxScan(val: number): this;\n\n    /**\n     * Sets the [maxTimeMS](https://docs.mongodb.com/manual/reference/method/cursor.maxTimeMS/)\n     * option. This will tell the MongoDB server to abort if the query or write op\n     * has been running for more than `ms` milliseconds.\n     */\n    maxTimeMS(ms: number): this;\n\n    /** Merges another Query or conditions object into this one. */\n    merge(source: Query<any, any> | FilterQuery<DocType>): this;\n\n    /** Specifies a `$mod` condition, filters documents for documents whose `path` property is a number that is equal to `remainder` modulo `divisor`. */\n    mod(val: Array<number>): this;\n    mod(path: string, val: Array<number>): this;\n\n    /** The model this query was created from */\n    model: typeof Model;\n\n    /**\n     * Getter/setter around the current mongoose-specific options for this query\n     * Below are the current Mongoose-specific options.\n     */\n    mongooseOptions(val?: MongooseQueryOptions): MongooseQueryOptions;\n\n    /** Specifies a `$ne` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    ne(val: any): this;\n    ne(path: string, val: any): this;\n\n    /** Specifies a `$near` or `$nearSphere` condition */\n    near(val: any): this;\n    near(path: string, val: any): this;\n\n    /** Specifies an `$nin` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    nin(val: Array<any>): this;\n    nin(path: string, val: Array<any>): this;\n\n    /** Specifies arguments for an `$nor` condition. */\n    nor(array: Array<FilterQuery<DocType>>): this;\n\n    /** Specifies arguments for an `$or` condition. */\n    or(array: Array<FilterQuery<DocType>>): this;\n\n    /**\n     * Make this query throw an error if no documents match the given `filter`.\n     * This is handy for integrating with async/await, because `orFail()` saves you\n     * an extra `if` statement to check if no document was found.\n     */\n    orFail(err?: NativeError | (() => NativeError)): QueryWithHelpers<NonNullable<ResultType>, DocType, THelpers, RawDocType>;\n\n    /** Specifies a `$polygon` condition */\n    polygon(...coordinatePairs: number[][]): this;\n    polygon(path: string, ...coordinatePairs: number[][]): this;\n\n    /** Specifies paths which should be populated with other documents. */\n    populate<Paths = {}>(path: string | any, select?: string | any, model?: string | Model<any, THelpers>, match?: any): QueryWithHelpers<UnpackedIntersection<ResultType, Paths>, DocType, THelpers, RawDocType>;\n    populate<Paths = {}>(options: PopulateOptions | Array<PopulateOptions>): QueryWithHelpers<UnpackedIntersection<ResultType, Paths>, DocType, THelpers, RawDocType>;\n\n    /** Get/set the current projection (AKA fields). Pass `null` to remove the current projection. */\n    projection(fields?: any | null): this;\n\n    /** Determines the MongoDB nodes from which to read. */\n    read(pref: string | mongodb.ReadPreferenceMode, tags?: any[]): this;\n\n    /** Sets the readConcern option for the query. */\n    readConcern(level: string): this;\n\n    /** Specifies a `$regex` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    regex(val: string | RegExp): this;\n    regex(path: string, val: string | RegExp): this;\n\n    /**\n     * Declare and/or execute this query as a remove() operation. `remove()` is\n     * deprecated, you should use [`deleteOne()`](#query_Query-deleteOne)\n     * or [`deleteMany()`](#query_Query-deleteMany) instead.\n     */\n    remove(filter?: FilterQuery<DocType>, callback?: Callback<mongodb.UpdateResult>): Query<mongodb.UpdateResult, DocType, THelpers, RawDocType>;\n\n    /**\n     * Declare and/or execute this query as a replaceOne() operation. Same as\n     * `update()`, except MongoDB will replace the existing document and will\n     * not accept any [atomic](https://docs.mongodb.com/manual/tutorial/model-data-for-atomic-operations/#pattern) operators (`$set`, etc.)\n     */\n    replaceOne(filter?: FilterQuery<DocType>, replacement?: DocType | AnyObject, options?: QueryOptions | null, callback?: Callback): QueryWithHelpers<any, DocType, THelpers, RawDocType>;\n    replaceOne(filter?: FilterQuery<DocType>, replacement?: DocType | AnyObject, options?: QueryOptions | null, callback?: Callback): QueryWithHelpers<any, DocType, THelpers, RawDocType>;\n\n    /** Specifies which document fields to include or exclude (also known as the query \"projection\") */\n    select(arg: string | any): this;\n\n    /** Determines if field selection has been made. */\n    selected(): boolean;\n\n    /** Determines if exclusive field selection has been made. */\n    selectedExclusively(): boolean;\n\n    /** Determines if inclusive field selection has been made. */\n    selectedInclusively(): boolean;\n\n    /**\n     * Sets the [MongoDB session](https://docs.mongodb.com/manual/reference/server-sessions/)\n     * associated with this query. Sessions are how you mark a query as part of a\n     * [transaction](/docs/transactions.html).\n     */\n    session(session: mongodb.ClientSession | null): this;\n\n    /**\n     * Adds a `$set` to this query's update without changing the operation.\n     * This is useful for query middleware so you can add an update regardless\n     * of whether you use `updateOne()`, `updateMany()`, `findOneAndUpdate()`, etc.\n     */\n    set(path: string | Record<string, unknown>, value?: any): this;\n\n    /** Sets query options. Some options only make sense for certain operations. */\n    setOptions(options: QueryOptions, overwrite?: boolean): this;\n\n    /** Sets the query conditions to the provided JSON object. */\n    setQuery(val: FilterQuery<DocType> | null): void;\n\n    setUpdate(update: UpdateQuery<DocType> | UpdateWithAggregationPipeline): void;\n\n    /** Specifies an `$size` query condition. When called with one argument, the most recent path passed to `where()` is used. */\n    size(val: number): this;\n    size(path: string, val: number): this;\n\n    /** Specifies the number of documents to skip. */\n    skip(val: number): this;\n\n    /** Specifies a `$slice` projection for an array. */\n    slice(val: number | Array<number>): this;\n    slice(path: string, val: number | Array<number>): this;\n\n    /** Specifies this query as a `snapshot` query. */\n    snapshot(val?: boolean): this;\n\n    /** Sets the sort order. If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`. */\n    sort(arg: string | any): this;\n\n    /** Sets the tailable option (for use with capped collections). */\n    tailable(bool?: boolean, opts?: {\n      numberOfRetries?: number;\n      tailableRetryInterval?: number;\n    }): this;\n\n    /**\n     * Executes the query returning a `Promise` which will be\n     * resolved with either the doc(s) or rejected with the error.\n     */\n    then: Promise<ResultType>['then'];\n\n    /** Converts this query to a customized, reusable query constructor with all arguments and options retained. */\n    toConstructor(): new (...args: any[]) => QueryWithHelpers<ResultType, DocType, THelpers, RawDocType>;\n\n    /** Declare and/or execute this query as an update() operation. */\n    update(filter?: FilterQuery<DocType>, update?: UpdateQuery<DocType> | UpdateWithAggregationPipeline, options?: QueryOptions | null, callback?: Callback<UpdateWriteOpResult>): QueryWithHelpers<UpdateWriteOpResult, DocType, THelpers, RawDocType>;\n\n    /**\n     * Declare and/or execute this query as an updateMany() operation. Same as\n     * `update()`, except MongoDB will update _all_ documents that match\n     * `filter` (as opposed to just the first one) regardless of the value of\n     * the `multi` option.\n     */\n    updateMany(filter?: FilterQuery<DocType>, update?: UpdateQuery<DocType> | UpdateWithAggregationPipeline, options?: QueryOptions | null, callback?: Callback<UpdateWriteOpResult>): QueryWithHelpers<UpdateWriteOpResult, DocType, THelpers, RawDocType>;\n\n    /**\n     * Declare and/or execute this query as an updateOne() operation. Same as\n     * `update()`, except it does not support the `multi` or `overwrite` options.\n     */\n    updateOne(filter?: FilterQuery<DocType>, update?: UpdateQuery<DocType> | UpdateWithAggregationPipeline, options?: QueryOptions | null, callback?: Callback<UpdateWriteOpResult>): QueryWithHelpers<UpdateWriteOpResult, DocType, THelpers, RawDocType>;\n\n    /**\n     * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n     * that must acknowledge this write before this write is considered successful.\n     */\n    w(val: string | number | null): this;\n\n    /** Specifies a path for use with chaining. */\n    where(path: string, val?: any): this;\n    where(obj: object): this;\n    where(): this;\n\n    /** Defines a `$within` or `$geoWithin` argument for geo-spatial queries. */\n    within(val?: any): this;\n\n    /**\n     * If [`w > 1`](/docs/api.html#query_Query-w), the maximum amount of time to\n     * wait for this write to propagate through the replica set before this\n     * operation fails. The default is `0`, which means no timeout.\n     */\n    wtimeout(ms: number): this;\n  }\n\n  export type QuerySelector<T> = {\n    // Comparison\n    $eq?: T;\n    $gt?: T;\n    $gte?: T;\n    $in?: [T] extends AnyArray<any> ? Unpacked<T>[] : T[];\n    $lt?: T;\n    $lte?: T;\n    $ne?: T;\n    $nin?: [T] extends AnyArray<any> ? Unpacked<T>[] : T[];\n    // Logical\n    $not?: T extends string ? QuerySelector<T> | RegExp : QuerySelector<T>;\n    // Element\n    /**\n     * When `true`, `$exists` matches the documents that contain the field,\n     * including documents where the field value is null.\n     */\n    $exists?: boolean;\n    $type?: string | number;\n    // Evaluation\n    $expr?: any;\n    $jsonSchema?: any;\n    $mod?: T extends number ? [number, number] : never;\n    $regex?: T extends string ? RegExp | string : never;\n    $options?: T extends string ? string : never;\n    // Geospatial\n    // TODO: define better types for geo queries\n    $geoIntersects?: { $geometry: object };\n    $geoWithin?: object;\n    $near?: object;\n    $nearSphere?: object;\n    $maxDistance?: number;\n    // Array\n    // TODO: define better types for $all and $elemMatch\n    $all?: T extends AnyArray<any> ? any[] : never;\n    $elemMatch?: T extends AnyArray<any> ? object : never;\n    $size?: T extends AnyArray<any> ? number : never;\n    // Bitwise\n    $bitsAllClear?: number | mongodb.Binary | number[];\n    $bitsAllSet?: number | mongodb.Binary | number[];\n    $bitsAnyClear?: number | mongodb.Binary | number[];\n    $bitsAnySet?: number | mongodb.Binary | number[];\n  };\n\n  export type RootQuerySelector<T> = {\n    /** @see https://docs.mongodb.com/manual/reference/operator/query/and/#op._S_and */\n    $and?: Array<FilterQuery<T>>;\n    /** @see https://docs.mongodb.com/manual/reference/operator/query/nor/#op._S_nor */\n    $nor?: Array<FilterQuery<T>>;\n    /** @see https://docs.mongodb.com/manual/reference/operator/query/or/#op._S_or */\n    $or?: Array<FilterQuery<T>>;\n    /** @see https://docs.mongodb.com/manual/reference/operator/query/text */\n    $text?: {\n        $search: string;\n        $language?: string;\n        $caseSensitive?: boolean;\n        $diacriticSensitive?: boolean;\n    };\n    /** @see https://docs.mongodb.com/manual/reference/operator/query/where/#op._S_where */\n    $where?: string | Function;\n    /** @see https://docs.mongodb.com/manual/reference/operator/query/comment/#op._S_comment */\n    $comment?: string;\n    // we could not find a proper TypeScript generic to support nested queries e.g. 'user.friends.name'\n    // this will mark all unrecognized properties as any (including nested queries)\n    [key: string]: any;\n  };\n\n  type ApplyBasicQueryCasting<T> = T | T[] | any;\n  type Condition<T> = ApplyBasicQueryCasting<T> | QuerySelector<ApplyBasicQueryCasting<T>>;\n\n  type _FilterQuery<T> = {\n    [P in keyof T]?: Condition<T[P]>;\n  } &\n    RootQuerySelector<T>;\n\n  export type FilterQuery<T> = _FilterQuery<T>;\n\n  type AddToSetOperators<Type> = {\n    $each: Type;\n  };\n\n  type SortValues = -1 | 1 | 'asc' | 'desc';\n\n  type ArrayOperator<Type> = {\n    $each: Type;\n    $slice?: number;\n    $position?: number;\n    $sort?: SortValues | Record<string, SortValues>;\n  };\n\n  type NumericTypes = number | Decimal128 | mongodb.Double | mongodb.Int32 | mongodb.Long;\n\n  type _UpdateQuery<TSchema> = {\n    /** @see https://docs.mongodb.com/manual/reference/operator/update-field/ */\n    $currentDate?: AnyKeys<TSchema> & AnyObject;\n    $inc?: AnyKeys<TSchema> & AnyObject;\n    $min?: AnyKeys<TSchema> & AnyObject;\n    $max?: AnyKeys<TSchema> & AnyObject;\n    $mul?: AnyKeys<TSchema> & AnyObject;\n    $rename?: { [key: string]: string };\n    $set?: AnyKeys<TSchema> & AnyObject;\n    $setOnInsert?: AnyKeys<TSchema> & AnyObject;\n    $unset?: AnyKeys<TSchema> & AnyObject;\n\n    /** @see https://docs.mongodb.com/manual/reference/operator/update-array/ */\n    $addToSet?: AnyKeys<TSchema> & AnyObject;\n    $pop?: AnyKeys<TSchema> & AnyObject;\n    $pull?: AnyKeys<TSchema> & AnyObject;\n    $push?: AnyKeys<TSchema> & AnyObject;\n    $pullAll?: AnyKeys<TSchema> & AnyObject;\n\n    /** @see https://docs.mongodb.com/manual/reference/operator/update-bitwise/ */\n    $bit?: {\n        [key: string]: { [key in 'and' | 'or' | 'xor']?: number };\n    };\n  };\n\n  type UpdateWithAggregationPipeline = UpdateAggregationStage[];\n  type UpdateAggregationStage = { $addFields: any } |\n    { $set: any } |\n    { $project: any } |\n    { $unset: any } |\n    { $replaceRoot: any } |\n    { $replaceWith: any };\n\n  type __UpdateDefProperty<T> =\n    [Extract<T, mongodb.ObjectId>] extends [never] ? T :\n    T | string;\n  type _UpdateQueryDef<T> = {\n    [K in keyof T]?: __UpdateDefProperty<T[K]>;\n  };\n\n  export type UpdateQuery<T> = _UpdateQuery<_UpdateQueryDef<T>> & AnyObject;\n\n  export type DocumentDefinition<T> = {\n    [K in keyof Omit<T, Exclude<keyof Document, '_id' | 'id' | '__v'>>]:\n      [Extract<T[K], mongodb.ObjectId>] extends [never]\n      ? T[K] extends TreatAsPrimitives\n        ? T[K]\n        : LeanDocumentElement<T[K]>\n      : T[K] | string;\n    };\n\n  export type FlattenMaps<T> = {\n    [K in keyof T]: T[K] extends Map<any, any>\n      ? AnyObject : T[K] extends TreatAsPrimitives\n      ? T[K] : FlattenMaps<T[K]>;\n  };\n\n  type actualPrimitives = string | boolean | number | bigint | symbol | null | undefined;\n  type TreatAsPrimitives = actualPrimitives |\n    NativeDate | RegExp | symbol | Error | BigInt | Types.ObjectId;\n\n  type LeanType<T> =\n    0 extends (1 & T) ? T : // any\n    T extends TreatAsPrimitives ? T : // primitives\n    T extends Types.Subdocument ? Omit<LeanDocument<T>, '$isSingleNested' | 'ownerDocument' | 'parent'> : // subdocs\n    LeanDocument<T>; // Documents and everything else\n\n  type LeanArray<T extends unknown[]> = T extends unknown[][] ? LeanArray<T[number]>[] : LeanType<T[number]>[];\n\n  export type _LeanDocument<T> = {\n    [K in keyof T]: LeanDocumentElement<T[K]>;\n  };\n\n  // Keep this a separate type, to ensure that T is a naked type.\n  // This way, the conditional type is distributive over union types.\n  // This is required for PopulatedDoc.\n  type LeanDocumentElement<T> =\n    T extends unknown[] ? LeanArray<T> : // Array\n    T extends Document ? LeanDocument<T> : // Subdocument\n    T;\n\n  export type SchemaDefinitionType<T> = T extends Document ? Omit<T, Exclude<keyof Document, '_id' | 'id' | '__v'>> : T;\n  export type LeanDocument<T> = Omit<_LeanDocument<T>, Exclude<keyof Document, '_id' | 'id' | '__v'> | '$isSingleNested'>;\n\n  export type LeanDocumentOrArray<T> = 0 extends (1 & T) ? T :\n    T extends unknown[] ? LeanDocument<T[number]>[] :\n    T extends Document ? LeanDocument<T> :\n    T;\n\n  export type LeanDocumentOrArrayWithRawType<T, RawDocType> = 0 extends (1 & T) ? T :\n    T extends unknown[] ? RawDocType[] :\n    T extends Document ? RawDocType :\n    T;\n\n  class QueryCursor<DocType> extends stream.Readable {\n    [Symbol.asyncIterator](): AsyncIterableIterator<DocType>;\n\n    /**\n     * Adds a [cursor flag](http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag).\n     * Useful for setting the `noCursorTimeout` and `tailable` flags.\n     */\n    addCursorFlag(flag: string, value: boolean): this;\n\n    /**\n     * Marks this cursor as closed. Will stop streaming and subsequent calls to\n     * `next()` will error.\n     */\n    close(): Promise<void>;\n    close(callback: CallbackWithoutResult): void;\n\n    /**\n     * Execute `fn` for every document(s) in the cursor. If batchSize is provided\n     * `fn` will be executed for each batch of documents. If `fn` returns a promise,\n     * will wait for the promise to resolve before iterating on to the next one.\n     * Returns a promise that resolves when done.\n     */\n    eachAsync(fn: (doc: DocType) => any, options?: { parallel?: number }): Promise<void>;\n    eachAsync(fn: (doc: DocType[]) => any, options: { parallel?: number, batchSize: number }): Promise<void>;\n    eachAsync(fn: (doc: DocType) => any, options?: { parallel?: number, batchSize?: number }, cb?: CallbackWithoutResult): void;\n    eachAsync(fn: (doc: DocType[]) => any, options: { parallel?: number, batchSize: number }, cb?: CallbackWithoutResult): void;\n\n    /**\n     * Registers a transform function which subsequently maps documents retrieved\n     * via the streams interface or `.next()`\n     */\n    map<ResultType>(fn: (res: DocType) => ResultType): QueryCursor<ResultType>;\n\n    /**\n     * Get the next document from this cursor. Will return `null` when there are\n     * no documents left.\n     */\n    next(): Promise<DocType>;\n    next(callback: Callback<DocType | null>): void;\n\n    options: any;\n  }\n\n  class Aggregate<R> {\n    /**\n     * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js\n     * You do not need to call this function explicitly, the JavaScript runtime\n     * will call it for you.\n     */\n    [Symbol.asyncIterator](): AsyncIterableIterator<Unpacked<R>>;\n\n    /**\n     * Sets an option on this aggregation. This function will be deprecated in a\n     * future release. */\n    addCursorFlag(flag: string, value: boolean): this;\n\n    /**\n     * Appends a new $addFields operator to this aggregate pipeline.\n     * Requires MongoDB v3.4+ to work\n     */\n    addFields(arg: PipelineStage.AddFields['$addFields']): this;\n\n    /** Sets the allowDiskUse option for the aggregation query (ignored for < 2.6.0) */\n    allowDiskUse(value: boolean): this;\n\n    /** Appends new operators to this aggregate pipeline */\n    append(...args: any[]): this;\n\n    /**\n     * Executes the query returning a `Promise` which will be\n     * resolved with either the doc(s) or rejected with the error.\n     * Like [`.then()`](#query_Query-then), but only takes a rejection handler.\n     */\n    catch: Promise<R>['catch'];\n\n    /** Adds a collation. */\n    collation(options: mongodb.CollationOptions): this;\n\n    /** Appends a new $count operator to this aggregate pipeline. */\n    count(countName: PipelineStage.Count['$count']): this;\n\n    /**\n     * Sets the cursor option for the aggregation query (ignored for < 2.6.0).\n     */\n    cursor(options?: Record<string, unknown>): AggregationCursor;\n\n    /** Executes the aggregate pipeline on the currently bound Model. */\n    exec(callback?: Callback<R>): Promise<R>;\n\n    /** Execute the aggregation with explain */\n    explain(callback?: Callback): Promise<any>;\n    explain(verbosity?: string, callback?: Callback): Promise<any>;\n\n    /** Combines multiple aggregation pipelines. */\n    facet(options: PipelineStage.Facet['$facet']): this;\n\n    /** Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection. */\n    graphLookup(options: PipelineStage.GraphLookup['$graphLookup']): this;\n\n    /** Appends new custom $group operator to this aggregate pipeline. */\n    group(arg: PipelineStage.Group['$group']): this;\n\n    /** Sets the hint option for the aggregation query (ignored for < 3.6.0) */\n    hint(value: Record<string, unknown> | string): this;\n\n    /**\n     * Appends a new $limit operator to this aggregate pipeline.\n     * @param num maximum number of records to pass to the next stage\n     */\n    limit(num: PipelineStage.Limit['$limit']): this;\n\n    /** Appends new custom $lookup operator to this aggregate pipeline. */\n    lookup(options: PipelineStage.Lookup['$lookup']): this;\n\n    /**\n     * Appends a new custom $match operator to this aggregate pipeline.\n     * @param arg $match operator contents\n     */\n    match(arg: PipelineStage.Match['$match']): this;\n\n    /**\n     * Binds this aggregate to a model.\n     * @param model the model to which the aggregate is to be bound\n     */\n    model(model: any): this;\n\n    /**\n     * Append a new $near operator to this aggregation pipeline\n     * @param arg $near operator contents\n     */\n    near(arg: { near?: number[]; distanceField: string; maxDistance?: number; query?: Record<string, any>; includeLocs?: string; num?: number; uniqueDocs?: boolean }): this;\n\n    /** Returns the current pipeline */\n    pipeline(): any[];\n\n    /** Appends a new $project operator to this aggregate pipeline. */\n    project(arg: PipelineStage.Project['$project']): this;\n\n    /** Sets the readPreference option for the aggregation query. */\n    read(pref: string | mongodb.ReadPreferenceMode, tags?: any[]): this;\n\n    /** Sets the readConcern level for the aggregation query. */\n    readConcern(level: string): this;\n\n    /** Appends a new $redact operator to this aggregate pipeline. */\n    redact(expression: any, thenExpr: string | any, elseExpr: string | any): this;\n\n    /** Appends a new $replaceRoot operator to this aggregate pipeline. */\n    replaceRoot(newRoot: PipelineStage.ReplaceRoot['$replaceRoot']['newRoot'] | string): this;\n\n    /**\n     * Helper for [Atlas Text Search](https://docs.atlas.mongodb.com/reference/atlas-search/tutorial/)'s\n     * `$search` stage.\n     */\n    search(options: PipelineStage.Search['$search']): this;\n\n    /** Lets you set arbitrary options, for middleware or plugins. */\n    option(value: Record<string, unknown>): this;\n\n    /** Appends new custom $sample operator to this aggregate pipeline. */\n    sample(size: number): this;\n\n    /** Sets the session for this aggregation. Useful for [transactions](/docs/transactions.html). */\n    session(session: mongodb.ClientSession | null): this;\n\n    /**\n     * Appends a new $skip operator to this aggregate pipeline.\n     * @param num number of records to skip before next stage\n     */\n    skip(num: number): this;\n\n    /** Appends a new $sort operator to this aggregate pipeline. */\n    sort(arg: PipelineStage.Sort['$sort']): this;\n\n    /** Provides promise for aggregate. */\n    then: Promise<R>['then'];\n\n    /**\n     * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name\n     * or a pipeline object.\n     */\n    sortByCount(arg: string | any): this;\n\n    /** Appends new $unionWith operator to this aggregate pipeline. */\n    unionWith(options: any): this;\n\n    /** Appends new custom $unwind operator(s) to this aggregate pipeline. */\n    unwind(...args: PipelineStage.Unwind['$unwind'][]): this;\n  }\n\n  class AggregationCursor extends stream.Readable {\n    /**\n     * Adds a [cursor flag](http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag).\n     * Useful for setting the `noCursorTimeout` and `tailable` flags.\n     */\n    addCursorFlag(flag: string, value: boolean): this;\n\n    /**\n     * Marks this cursor as closed. Will stop streaming and subsequent calls to\n     * `next()` will error.\n     */\n    close(): Promise<void>;\n    close(callback: CallbackWithoutResult): void;\n\n    /**\n     * Execute `fn` for every document(s) in the cursor. If batchSize is provided\n     * `fn` will be executed for each batch of documents. If `fn` returns a promise,\n     * will wait for the promise to resolve before iterating on to the next one.\n     * Returns a promise that resolves when done.\n     */\n    eachAsync(fn: (doc: any) => any, options?: { parallel?: number, batchSize?: number }): Promise<void>;\n    eachAsync(fn: (doc: any) => any, options?: { parallel?: number, batchSize?: number }, cb?: CallbackWithoutResult): void;\n\n    /**\n     * Registers a transform function which subsequently maps documents retrieved\n     * via the streams interface or `.next()`\n     */\n    map(fn: (res: any) => any): this;\n\n    /**\n     * Get the next document from this cursor. Will return `null` when there are\n     * no documents left.\n     */\n    next(): Promise<any>;\n    next(callback: Callback): void;\n  }\n\n  /**\n   * [Stages reference](https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/#aggregation-pipeline-stages)\n   */\n  export type PipelineStage =\n    | PipelineStage.AddFields\n    | PipelineStage.Bucket\n    | PipelineStage.BucketAuto\n    | PipelineStage.CollStats\n    | PipelineStage.Count\n    | PipelineStage.Facet\n    | PipelineStage.GeoNear\n    | PipelineStage.GraphLookup\n    | PipelineStage.Group\n    | PipelineStage.IndexStats\n    | PipelineStage.Limit\n    | PipelineStage.ListSessions\n    | PipelineStage.Lookup\n    | PipelineStage.Match\n    | PipelineStage.Merge\n    | PipelineStage.Out\n    | PipelineStage.PlanCacheStats\n    | PipelineStage.Project\n    | PipelineStage.Redact\n    | PipelineStage.ReplaceRoot\n    | PipelineStage.ReplaceWith\n    | PipelineStage.Sample\n    | PipelineStage.Search\n    | PipelineStage.Set\n    | PipelineStage.SetWindowFields\n    | PipelineStage.Skip\n    | PipelineStage.Sort\n    | PipelineStage.SortByCount\n    | PipelineStage.UnionWith\n    | PipelineStage.Unset\n    | PipelineStage.Unwind\n\n  export namespace PipelineStage {\n    export interface AddFields {\n      /** [`$addFields` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/) */\n      $addFields: Record<string, any>\n    }\n\n    export interface Bucket {\n      /** [`$bucket` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/bucket/) */\n      $bucket: {\n        groupBy: any\n        boundaries: any[]\n        default?: any\n        output?: Record<string, { [op in AccumulatorOperator]?: any }>\n      }\n    }\n\n    export interface BucketAuto {\n      /** [`$bucketAuto` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/bucketAuto/) */\n      $bucketAuto: {\n        groupBy: any\n        buckets: number\n        output?: Record<string, { [op in AccumulatorOperator]?: any }>\n        granularity?: 'R5' | 'R10' | 'R20' | 'R40' | 'R80' | '1-2-5' | 'E6' | 'E12' | 'E24' | 'E48' | 'E96' | 'E192' | 'POWERSOF2'\n      }\n    }\n\n    export interface CollStats {\n      /** [`$collStats` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/collStats/) */\n      $collStats: {\n        latencyStats?: { histograms?: boolean }\n        storageStats?: { scale?: number }\n        count?: {}\n        queryExecStats?: {}\n      }\n    }\n\n    export interface Count {\n      /** [`$count` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/count/) */\n      $count: string\n    }\n\n    export interface Facet {\n      /** [`$facet` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/facet/) */\n      $facet: Record<string, FacetPipelineStage[]>\n    }\n\n    export type FacetPipelineStage = Exclude<PipelineStage, PipelineStage.CollStats | PipelineStage.Facet | PipelineStage.GeoNear | PipelineStage.IndexStats | PipelineStage.Out | PipelineStage.Merge | PipelineStage.PlanCacheStats>\n\n    export interface GeoNear {\n      /** [`$geoNear` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/geoNear/) */\n      $geoNear: {\n        near: { type: 'Point'; coordinates: [number, number] } | [number, number]\n        distanceField: string\n        distanceMultiplier?: number\n        includeLocs?: string\n        key?: string\n        maxDistance?: number\n        minDistance?: number\n        query?: AnyObject\n        spherical?: boolean\n        uniqueDocs?: boolean\n      }\n    }\n\n    export interface GraphLookup {\n      /** [`$graphLookup` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/) */\n      $graphLookup: {\n        from: string\n        startWith: any\n        connectFromField: string\n        connectToField: string\n        as: string\n        maxDepth?: number\n        depthField?: string\n        restrictSearchWithMatch?: AnyObject\n      }\n    }\n\n    export interface Group {\n      /** [`$group` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/group) */\n      $group: { _id: any } | { [key: string]: { [op in AccumulatorOperator]?: any } }\n    }\n\n    export interface IndexStats {\n      /** [`$indexStats` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/indexStats/) */\n      $indexStats: {}\n    }\n\n    export interface Limit {\n      /** [`$limit` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/limit/) */\n      $limit: number\n    }\n\n    export interface ListSessions {\n      /** [`$listSessions` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/listSessions/) */\n      $listSessions: { users?: { user: string; db: string }[] } | { allUsers?: true }\n    }\n\n    export interface Lookup {\n      /** [`$lookup` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/) */\n      $lookup: {\n        from: string\n        as: string\n        localField?: string\n        foreignField?: string\n        let?: Record<string, any>\n        pipeline?: Exclude<PipelineStage, PipelineStage.Merge | PipelineStage.Out | PipelineStage.Search>[]\n      }\n    }\n\n    export interface Match {\n      /** [`$match` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) */\n      $match: AnyObject\n    }\n\n    export interface Merge {\n      /** [`$merge` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/merge/) */\n      $merge: {\n        into: string | { db: string; coll: string }\n        on?: string | string[]\n        let?: Record<string, any>\n        whenMatched?: 'replace' | 'keepExisting' | 'merge' | 'fail' | Extract<PipelineStage, PipelineStage.AddFields | PipelineStage.Set | PipelineStage.Project | PipelineStage.Unset | PipelineStage.ReplaceRoot | PipelineStage.ReplaceWith>[]\n        whenNotMatched?: 'insert' | 'discard' | 'fail'\n      }\n    }\n\n    export interface Out {\n      /** [`$out` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/out/) */\n      $out: string | { db: string; coll: string }\n    }\n\n    export interface PlanCacheStats {\n      /** [`$planCacheStats` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/planCacheStats/) */\n      $planCacheStats: {}\n    }\n\n    export interface Project {\n      /** [`$project` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) */\n      $project: { [field: string]: any }\n    }\n\n    export interface Redact {\n      /** [`$redact` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/redact/) */\n      $redact: any\n    }\n\n    export interface ReplaceRoot {\n      /** [`$replaceRoot` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/replaceRoot/) */\n      $replaceRoot: { newRoot: any }\n    }\n\n    export interface ReplaceWith {\n      /** [`$replaceWith` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/replaceWith/) */\n      $replaceWith: any\n    }\n\n    export interface Sample {\n      /** [`$sample` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/sample/) */\n      $sample: { size: number }\n    }\n\n    export interface Search {\n      /** [`$search` reference](https://docs.atlas.mongodb.com/reference/atlas-search/query-syntax/) */\n      $search: {\n        [key: string]: any\n        index?: string\n        highlight?: { path: string; maxCharsToExamine?: number; maxNumPassages?: number }\n      }\n    }\n\n    export interface Set {\n      /** [`$set` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/set/) */\n      $set: Record<string, any>\n    }\n\n    export interface SetWindowFields {\n      /** [`$setWindowFields` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/setWindowFields/) */\n      $setWindowFields: {\n        partitionBy?: any\n        sortBy?: Record<string, 1 | -1>\n        output: Record<\n          string,\n          { [op in WindowOperator]?: any } & {\n            window?: {\n              documents?: [string | number, string | number]\n              range?: [string | number, string | number]\n              unit?: 'year' | 'quarter' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond'\n            }\n          }\n        >\n      }\n    }\n\n    export interface Skip {\n      /** [`$skip` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/skip/) */\n      $skip: number\n    }\n\n    export interface Sort {\n      /** [`$sort` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/sort/) */\n      $sort: Record<string, 1 | -1 | { $meta: 'textScore' }>\n    }\n\n    export interface SortByCount {\n      /** [`$sortByCount` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/) */\n      $sortByCount: any\n    }\n\n    export interface UnionWith {\n      /** [`$unionWith` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/unionWith/) */\n      $unionWith:\n        | string\n        | { coll: string; pipeline?: Exclude<PipelineStage, PipelineStage.Out | PipelineStage.Merge>[] }\n    }\n\n    export interface Unset {\n      /** [`$unset` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/unset/) */\n      $unset: string | string[]\n    }\n\n    export interface Unwind {\n      /** [`$unwind` reference](https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/) */\n      $unwind: string | { path: string; includeArrayIndex?: string; preserveNullAndEmptyArrays?: boolean }\n    }\n\n    type AccumulatorOperator = '$accumulator' | '$addToSet' | '$avg' | '$count' | '$first' | '$last' | '$max' | '$mergeObjects' | '$min' | '$push' | '$stdDevPop' | '$stdDevSamp' | '$sum'\n\n    type WindowOperator = '$addToSet' | '$avg' | '$count' | '$covariancePop' | '$covarianceSamp' | '$derivative' | '$expMovingAvg' | '$integral' | '$max' | '$min' | '$push' | '$stdDevSamp' | '$stdDevPop' | '$sum' | '$first' | '$last' | '$shift' | '$denseRank' | '$documentNumber' | '$rank'\n  }\n\n  class SchemaType {\n    /** SchemaType constructor */\n    constructor(path: string, options?: AnyObject, instance?: string);\n\n    /** Get/set the function used to cast arbitrary values to this type. */\n    static cast(caster?: Function | boolean): Function;\n\n    static checkRequired(checkRequired?: (v: any) => boolean): (v: any) => boolean;\n\n    /** Sets a default option for this schema type. */\n    static set(option: string, value: any): void;\n\n    /** Attaches a getter for all instances of this schema type. */\n    static get(getter: (value: any) => any): void;\n\n    /** The class that Mongoose uses internally to instantiate this SchemaType's `options` property. */\n    OptionsConstructor: typeof SchemaTypeOptions;\n\n    /** Cast `val` to this schema type. Each class that inherits from schema type should implement this function. */\n    cast(val: any, doc: Document<any>, init: boolean, prev?: any, options?: any): any;\n\n    /** Sets a default value for this SchemaType. */\n    default(val: any): any;\n\n    /** Adds a getter to this schematype. */\n    get(fn: Function): this;\n\n    /**\n     * Defines this path as immutable. Mongoose prevents you from changing\n     * immutable paths unless the parent document has [`isNew: true`](/docs/api.html#document_Document-isNew).\n     */\n    immutable(bool: boolean): this;\n\n    /** Declares the index options for this schematype. */\n    index(options: any): this;\n\n    /** String representation of what type this is, like 'ObjectID' or 'Number' */\n    instance: string;\n\n    /** The options this SchemaType was instantiated with */\n    options: AnyObject;\n\n    /**\n     * Set the model that this path refers to. This is the option that [populate](https://mongoosejs.com/docs/populate.html)\n     * looks at to determine the foreign collection it should query.\n     */\n    ref(ref: string | boolean | Model<any>): this;\n\n    /**\n     * Adds a required validator to this SchemaType. The validator gets added\n     * to the front of this SchemaType's validators array using unshift().\n     */\n    required(required: boolean, message?: string): this;\n\n    /** The schema this SchemaType instance is part of */\n    schema: Schema<any>;\n\n    /** Sets default select() behavior for this path. */\n    select(val: boolean): this;\n\n    /** Adds a setter to this schematype. */\n    set(fn: Function): this;\n\n    /** Declares a sparse index. */\n    sparse(bool: boolean): this;\n\n    /** Declares a full text index. */\n    text(bool: boolean): this;\n\n    /** Defines a custom function for transforming this path when converting a document to JSON. */\n    transform(fn: (value: any) => any): this;\n\n    /** Declares an unique index. */\n    unique(bool: boolean): this;\n\n    /** Adds validator(s) for this document path. */\n    validate(obj: RegExp | Function | any, errorMsg?: string,\n      type?: string): this;\n  }\n\n  type Callback<T = any> = (error: CallbackError, result: T) => void;\n\n  type CallbackWithoutResult = (error: CallbackError) => void;\n\n  class NativeError extends global.Error { }\n  type CallbackError = NativeError | null;\n\n  class Error extends global.Error {\n    constructor(msg: string);\n\n    /** The type of error. \"MongooseError\" for generic errors. */\n    name: string;\n\n    static messages: any;\n\n    static Messages: any;\n  }\n\n  namespace Error {\n    export class CastError extends Error {\n      name: 'CastError';\n      stringValue: string;\n      kind: string;\n      value: any;\n      path: string;\n      reason?: NativeError | null;\n      model?: any;\n\n      constructor(type: string, value: any, path: string, reason?: NativeError, schemaType?: SchemaType);\n    }\n\n    export class DisconnectedError extends Error {\n      name: 'DisconnectedError';\n    }\n\n    export class DivergentArrayError extends Error {\n      name: 'DivergentArrayError';\n    }\n\n    export class MissingSchemaError extends Error {\n      name: 'MissingSchemaError';\n    }\n\n    export class DocumentNotFoundError extends Error {\n      name: 'DocumentNotFoundError';\n      result: any;\n      numAffected: number;\n      filter: any;\n      query: any;\n    }\n\n    export class ObjectExpectedError extends Error {\n      name: 'ObjectExpectedError';\n      path: string;\n    }\n\n    export class ObjectParameterError extends Error {\n      name: 'ObjectParameterError';\n    }\n\n    export class OverwriteModelError extends Error {\n      name: 'OverwriteModelError';\n    }\n\n    export class ParallelSaveError extends Error {\n      name: 'ParallelSaveError';\n    }\n\n    export class ParallelValidateError extends Error {\n      name: 'ParallelValidateError';\n    }\n\n    export class MongooseServerSelectionError extends Error {\n      name: 'MongooseServerSelectionError';\n    }\n\n    export class StrictModeError extends Error {\n      name: 'StrictModeError';\n      isImmutableError: boolean;\n      path: string;\n    }\n\n    export class ValidationError extends Error {\n      name: 'ValidationError';\n\n      errors: { [path: string]: ValidatorError | CastError | ValidationError };\n      addError: (path: string, error: ValidatorError | CastError | ValidationError) => void;\n\n      constructor(instance?: Error);\n    }\n\n    export class ValidatorError extends Error {\n      name: 'ValidatorError';\n      properties: {\n        message: string,\n        type?: string,\n        path?: string,\n        value?: any,\n        reason?: any\n      };\n      kind: string;\n      path: string;\n      value: any;\n      reason?: Error | null;\n\n      constructor(properties: {\n        message?: string,\n        type?: string,\n        path?: string,\n        value?: any,\n        reason?: any\n      });\n    }\n\n    export class VersionError extends Error {\n      name: 'VersionError';\n      version: number;\n      modifiedPaths: Array<string>;\n\n      constructor(doc: Document, currentVersion: number, modifiedPaths: Array<string>);\n    }\n  }\n\n  /* for ts-mongoose */\n  class mquery {}\n}\n"
        }
    ]
}